;*********************************;;         OBJ2PRG20;      OBJ2PRG.V20 V072882;CONVERT OBJECT FILE FROM ASSEMBLER64;        TO PROGRAM FILE; (C) 1982 BY COMMODORE MACHINES;;  WRITTEN BY DENTON MARLOWE;*********************************; MAIN BODY OF CODE;*********************************; ZEROPAGE USAGE EQUATES;*********************************STATUS=$90         ;STATUS BYTELA    =$B8         ;CURRENT LOGICAL DEVICE NUMBERSA    =$B9         ;CURRENT SECONDARY ADDRESSFA    =$BA         ;CURRENT DEVICE NUMBERZEROPG=$FB         ;ZERO PAGE POINTERZEROUR=$FD         ;ZERO PAGE POINTER;*********************************; KERNAL JMUP TABLE EQUATES;*********************************TALKSA=$FF96       ;SERIAL TALK SAIECIN =$FFA5       ;SERIAL INUNTALK=$FFAB       ;SERIAL UNTALKSTOP  =$FFE1       ;CHECK FOR STOPTALK  =$FFB4       ;SERIAL TALKSETLFS=$FFBA       ;SET LOGICAL FILESETNAM=$FFBD       ;SET FILENAMEOPEN  =$FFC0       ;OPEN FILECLOSE =$FFC3       ;CLOSE LOGICAL FILECHKIN =$FFC6       ;OPEN INPUT CHANNELCHKOUT=$FFC9       ;OPEN OUTPUT CHANNELCLRCHN=$FFCC       ;RESET I/O CHANNELSCHRIN =$FFCF       ;GET KEYBOARD INPUTCHROUT=$FFD2       ;OUTPUT CHARACTERREADST=$FFB7       ;READ I/O STATUS;*********************************;; OBJ2PRG ENTRY POINT;;*********************************OBJPRG =*       JSR CLRCHN    ;RSET I/O       LDA #$00      ;ZERO BYTE       STA RECORD    ;RECORD COUNT       STA RECORD+1  ;       STA STADD     ;START ADDRESS       STA STATUS    ;I/O STATUS       STA SCROPT    ;SCREEN OUTPUT OPTION;*********************************; INIT DISK;*********************************INITD  =*       LDA #$02    ;LENGTH OF FILENAME       LDY #>INIT  ;HIGH ADDRESS OF FILENAME       LDX #<INIT  ;LOW ADDRESS OF FILENAME       JSR SETNAM  ;SET FILE NAME       LDA #$0F    ;FILE #15       LDX #$08    ;DEVICE #8       LDY #$0F    ;SECONDARY ADDRESS #15 (CMD)       JSR SETLFS  ;SET FILE PARAMETERS       JSR OPEN    ;OPEN FILE       LDA #$0F    ;FILE #15       JSR CLOSE   ;CLOSE IT       JSR DISERR  ;LOW LEVEL CHECK DISK ERROR       BCC INITOK  ;IF C=0 NO ERRORS       JMP QUITER  ;DISK ERROR, QUIT;*********************************; OPEN FILE TO SCREEN;*********************************INITOK =*       LDA #$03    ;FILE #3       LDX #$03    ;DEVICE #3       LDY #$00    ;SECOND ADDRESS       JSR SETLFS  ;SET FILE;       LDA #$00    ;GET LENGTH       LDX #$00    ;LOW FILENAME       LDY #$00    ;HIGH FILENAME       JSR SETNAM  ;SET FILENAME       JSR OPEN    ;OPEN FILE        LDX #$03    ;FILE #3       JSR CHKOUT  ;SET TO OUTPUT;*********************************; PRINT TITLE;*********************************       LDX #MSG7-MSG1 ;OFFSET FOR TITLE       JSR PRINT      ;PRINT TITLE;*********************************; PROMPT FOR OBJ FILENAME;*********************************       LDX #MSG8-MSG1 ;OFFSET FOR MSG       JSR PRINT      ;PRG NAME:;*********************************; READ IN INTERFACE FILE NAME;*********************************       JSR INSTNO  ;READ STRING INTO OBUF;*********************************; APPEND ,S,R;*********************************PFILE0 LDX #$00PFILE1 LDA OBJM,X       STA OUF,Y       INY       INX       CPX #$04       BNE PFILE1       STY SAVO ; LENGTH OF FILE NAME;*********************************; OUTPUT CARRAIGE RETURN;*********************************       JSR PRTCR  ;PRINT IT;*********************************; PROMPT FOR PRG FILENAME;*********************************       LDX #MSG9-MSG1 ;OFFSET FOR MSG       JSR PRINT      ;PRG NAME:;*********************************; READ IN PRG FILE NAME;*********************************       JSR INSTNP  ;READ STRING INTO PBUF;*********************************; APPEND ,P,W;*********************************PFILE2 LDX #$00PFILE3 LDA PROGM,X       STA PUF,Y       INY       INX       CPX #$04       BNE PFILE3       STY SAVP    ; LENGTH OF FILE NAME;*********************************; SCREEN OUTPUT OPTION (VERBOSE);*********************************       LDA #<MSS1  ;LOW BYTE MESSAGE       LDY #>MSS1  ;HIGH BYTE MESSAGE       JSR STRPNT  ;OUTPUT MESSAGE       JSR CRNO    ;GET KEY PRESS       BCS SOP1    ;C=0 YES C=1 NO       LDA #$00    ;ZERO       STA SCROPT  ;PRINT TO SCREEN       BEQ OPENOF  ;SLIP NEXTSOP1   LDA #$01    ;ONE       STA SCROPT  ;NO PRINT TO SCREEN ;*********************************; OPEN OBJECT FILE;*********************************OPENOF =*       LDA #$07    ;FILE #7       LDX #$08    ;DEVICE #8       LDY #$07    ;SECOND ADDRESS       JSR SETLFS  ;SET FILE;       LDA SAVO    ;GET LENGTH       LDX #<OUF   ;LOW FILENAME       LDY #>OUF   ;HIGH FILENAME       JSR SETNAM  ;SET FILENAME;       JSR OPEN    ;OPEN FILE;       JSR DISERR       BCC OBJOK       JMP QUITER;*********************************; OPEN PROGRAM FILE;*********************************OBJOK =*       LDA #$08    ;FILE #7       LDX #$08    ;DEVICE #8       LDY #$08    ;SECOND ADDRESS       JSR SETLFS  ;SET FILE;       LDA SAVP    ;GET LENGTH       LDX #<PUF   ;LOW FILENAME       LDY #>PUF   ;HIGH FILENAME       JSR SETNAM  ;SET FILENAME       JSR OPEN    ;OPEN FILE;       JSR DISERR       BCC PRGOK       JMP QUITER;*********************************; SET INPUT TO OBJECT FILE;*********************************PRGOK =*       LDX #$07    ;FILE #7       JSR CHKIN   ;INPUT FILE;*********************************; NEW LINE - CR;*********************************       JSR PRTCR  ;OUTPUT TO SCREEN;*********************************; LOOP;*********************************CKSTOP =*       JSR STOP    ;CHECK STOP       BNE OK2     ;IF NOT GO ON.       JMP BREAK   ;BREAK ERROR;*********************************; INPUT CODE IN CBM OBJECT FORMAT;*********************************; RECORD STARTS WITH ;;*********************************OK2 =*       JSR INPUT   ;INPUT CHAR       CMP #';'    ;START OF RECORD       BEQ ROK     ;IF EQUAL GOOD RECORD       JMP RERROR  ;RECORD ERRORROK    JSR CHROUT  ;OUTPUT TO SCREEN;*********************************; NEXT READ TWO DIGIT BYTE COUNT;*********************************       JSR INPUT   ;INPUT CHAR       STA DIGIT1  ;SAVE CHAR       JSR CHRIN   ;INPUT CHAR       STA DIGIT2  ;SAVE CHAR       JSR GETBYT  ;GET BYTE       STA NUMBYT  ;NUMBER BYTES IN RECORD;*********************************; LAST RECORD AS COUNT OF ZERO;*********************************       CMP #$00        ;IF BYTE COUNT ZERO       BNE GOON        ;NO THEN CONTINUE       LDX #MSG16-MSG1 ;OFFSET COUNT       JSR PRINT       ;PRINT HEADING       JMP QUITER      ;DONE;*********************************; PRINT NUMBER BYTES;*********************************GOON =*       LDA SCROPT       BNE SKIP1;       LDX #MSG12-MSG1 ;OFFSET COUNT       JSR PRINT       ;PRINT HEADING       LDA DIGIT1      ;GET CHAR       JSR CHROUT      ;PRINT IT       LDA DIGIT2      ;GET CHAR       JSR CHROUT      ;PRINT IT       JSR PRTCR       ;PRINT CR;*********************************; INPUT RECORD ADDRESS;*********************************SKIP1 =*       JSR INPUT   ;INPUT CHAR       STA DIGIT1  ;SAVE CHAR       JSR CHRIN   ;INPUT CHAR       STA DIGIT2  ;SAVE CHAR       JSR CHRIN   ;INPUT CHAR       STA DIGIT3  ;SAVE CHAR       JSR CHRIN   ;INPUT CHAR       STA DIGIT4  ;SAVE CHAR       JSR GETADD  ;GET BYTE       LDA STADD   ;CHECK START ADDRESS FLAG       BNE SKPADD  ;IF NOT ZERO WE HAVE ALREADY WRITTEN ADDRESS;*********************************; ONE TIME PRINT ADDRESS TO FILE;*********************************       LDX #$08    ;FILE #8       JSR CHKOUT  ;SET TO OUTPUT       LDA ADDLO   ;LOW BYTE ADDRESS       JSR CHROUT  ;WRITE IT TO FILE       LDA ADDHI   ;HIGH BYTE ADDRESS       JSR CHROUT  ;WRITE IT TO FILE       LDX #$03    ;FILE #3       JSR CHKOUT  ;SET TO OUTPUT;*********************************; SAVE INITIAL PROGRAM MEMORY ADDRESS;*********************************       LDA ADDLO       STA RECLO  ;RECORD ADDRESS LOW BYTE       LDA ADDHI       STA RECHI  ;RECORD ADDRESS HIGH BYTE;*********************************; SET FLAG TO SKIP PRINTING ADDRESS;*********************************       LDA #$01    ;LOAD NONZERO VALUE       STA STADD   ;SET START ADDRESS FLAG;*********************************; PRINT ADDRESS;*********************************SKPADD =*;*********************************; CHECK RECORD ADDRESS TO MAKE SURE; THE OBJECT FILE IS CONTIGOUS;*********************************       LDA RECLO       CMP ADDLO       BNE NONC       LDA RECHI       CMP ADDHI       BEQ YESCNONC = *       LDX #MSG17-MSG1 ;OFFSET ADDRESS       JSR PRINT       ;PRINT HEADING       ;JMP QUITER       JSR PADIT;*********************************; PRINT ADDRESS;*********************************YESC =*       LDA SCROPT       BNE SKIP2;       LDX #MSG11-MSG1 ;OFFSET ADDRESS       JSR PRINT       ;PRINT HEADING       LDA DIGIT1      ;GET CHAR       JSR CHROUT      ;PRINT IT       LDA DIGIT2      ;GET CHAR       JSR CHROUT      ;PRINT IT       LDA DIGIT3      ;GET CHAR       JSR CHROUT      ;PRINT IT       LDA DIGIT4      ;GET CHAR       JSR CHROUT      ;PRINT IT       JSR PRTCR       ;PRINT CR;*********************************; PRINT BYTE DATA HEADER;*********************************       LDX #MSG13-MSG1 ;OFFSET BYTE DATA       JSR PRINT       ;PRINT HEADING;*********************************; INPUT RECORD;*********************************SKIP2 =*       LDX #$00       STX CURBYT;*********************************; INPUT RECORD BYTE DATA;*********************************NEXTBY =*       JSR INPUT   ;INPUT CHAR       STA DIGIT1  ;SAVE CHAR       JSR CHRIN   ;INPUT CHAR       STA DIGIT2  ;SAVE CHAR       JSR GETBYT  ;GET BYTE       LDX CURBYT  ;GET CURRENT BYTE COUNTER       STA CURDAT  ;SAVE CURRENT BYTE       STA DATA,X  ;SAVE BYTE IN RECORD BUFFER;*********************************; PRINT BYTE TO FILE ;*********************************       JSR CLRCHN  ;RESET I/O        LDX #$08    ;FILE #8       JSR CHKOUT  ;SET TO OUTPUT       LDA CURDAT  ;DATA BYTE       JSR CHROUT  ;WRITE IT TO FILE       JSR CLRCHN  ;RESET I/O        LDX #$03    ;FILE #3       JSR CHKOUT  ;SET TO OUTPUT;*********************************; PRINT BYTE TO SCREEN ;*********************************       LDA SCROPT       BNE SKIP3;       LDA DIGIT1       JSR CHROUT       LDA DIGIT2       JSR CHROUT       LDA #' '       JSR CHROUT ;SKIP3 =*       LDX CURBYT       INX       STX CURBYT       CPX NUMBYT       BNE NEXTBY;*********************************; INPUT RECORD CHECKSUM;*********************************       JSR INPUT   ;INPUT CHAR       STA DIGIT1  ;SAVE CHAR       JSR CHRIN   ;INPUT CHAR       STA DIGIT2  ;SAVE CHAR       JSR CHRIN   ;INPUT CHAR       STA DIGIT3  ;SAVE CHAR       JSR CHRIN   ;INPUT CHAR       STA DIGIT4  ;SAVE CHAR       JSR GETADD  ;CONVERT TO WORD;*********************************; PRINT 4 BYTE CHECKSUM;*********************************       LDA SCROPT       BNE SKIP4;       LDX #MSG14-MSG1 ;OFFSET ADDRESS       JSR PRINT       ;PRINT HEADING       LDA DIGIT1       JSR CHROUT       LDA DIGIT2       JSR CHROUT       LDA DIGIT3       JSR CHROUT       LDA DIGIT4       JSR CHROUT;*********************************; READ AND PRINT RECORD END CR;*********************************SKIP4 =*       JSR INPUT   ;INPUT CHAR       LDA SCROPT       BNE SKIP5       JSR CHROUT  ;PRINT IT;*********************************; NEXT LINE ON DISPLAY;*********************************       JSR PRTCR   ;PRINT CR;*********************************; NEXT RECORD;*********************************SKIP5 =*;*********************************; ADVANCE RECORD ADDRESS BY NUMBER BYTES; READ IN TO CHECK NEXT RECORD; FOR CONTIGUOUS MEMORY;*********************************       CLC       LDA NUMBYT       ADC RECLO       STA RECLO       LDA #$00       ADC RECHI       STA RECHI;*********************************; NEXT RECORD;*********************************       JMP CKSTOP  ;NEXT RECORD;*********************************; ERRORS;*********************************; PADDING NEGATIVE ERROR;*********************************PADERR =*       LDX #MSG4-MSG1 ;OFFSET ADDRESS       .BYTE $2C      ;BIT TRICK TO SKIP;*********************************;RECORD ERROR;*********************************RERROR =*       LDX #MSG4-MSG1 ;OFFSET FOR MSG       .BYTE $2C      ;BIT TRICK TO SKIP;*********************************; BREAK MESSAGE - STOP KEY PRESSED;*********************************BREAK =*        LDX #MSG2-MSG1 ;BREAK ERROR       .BYTE $2C      ;BIT TRICK TO SKIP;*********************************; END OF RECORDS - CLOSE OUT;*********************************QUITER =*       LDX #MSG15-MSG1 ;END OF FILE;*********************************; OUTPUT MESSAGE TO SCREEN;*********************************       JSR PRINT   ;PRINT HEADING;*********************************; CLOSE OUT FILE AND RESET I/O;*********************************       LDA #$03    ;FILE #7       JSR CLOSE   ;CLOSE       LDA #$07    ;FILE #7       JSR CLOSE   ;CLOSE       LDA #$08    ;FILE #7       JSR CLOSE   ;CLOSE       JSR CLRCHN  ;RESET I/O        RTS         ;BACK TO BASIC;*********************************; INPUT CHARACTER INTO BYTE; CREATE BYTE FORM 2 ASCII CHARS;*********************************GETADD =*       LDA DIGIT1       JSR BYTASC  ;GET HIGH NIBBLE       ASL A       ;LEFT JUSTIFY       ASL A       ; ASCII CHAR       ASL A       ;  IN HIGH       ASL A       ;   NIBBLE       STA TEMP    ;STORE       LDA DIGIT2  ;INPUT CHAR       JSR BYTASC  ;CREATE LOW NIB       ORA TEMP         ;PUT IN PLACE       STA ADDHI        ;HIGH NIBBLE;       LDA DIGIT3       JSR BYTASC  ;GET HIGH NIBBLE       ASL A       ;LEFT JUSTIFY       ASL A       ; ASCII CHAR       ASL A       ;  IN HIGH       ASL A       ;   NIBBLE       STA TEMP    ;STORE       LDA DIGIT4  ;INPUT CHAR       JSR BYTASC  ;CREATE LOW NIB       ORA TEMP    ;PUT IN PLACE       STA ADDLO   ;LO NIBBLE;       RTS         ;RETURN;*********************************; INPUT CHARACTER INTO BYTE; CREATE BYTE FORM 2 ASCII CHARS;*********************************GETBYT =*       LDA DIGIT1       JSR BYTASC  ;GET HIGH NIBBLE       ASL A       ;LEFT JUSTIFY       ASL A       ; ASCII CHAR       ASL A       ;  IN HIGH       ASL A       ;   NIBBLE       STA TEMP    ;STORE       LDA DIGIT2  ;INPUT CHAR       JSR BYTASC  ;CREATE LOW NIB       ORA TEMP    ;PUT IN PLACE       RTS         ;RETURN;*********************************; CONVERT ASCII TO BYTE DATA;*********************************BYTASC CMP #$3A    ;IS CHAR >9       PHP         ;PUSH P       AND #$0F    ;MASK HIGH BYTE       PLP         ;PULL P       BCC EXIT1   ;IF <=9 OK       ADC #$08    ;ADD OFFSETEXIT1  RTS         ;RETURN;*********************************; CONVERT BYTE TO ASCII CHAR;*********************************CHGASC CLC         ;CLEAR CARRY       ADC #$F6    ;ADD OFFSET       BCC NOSIX   ;IF C=0 OK       ADC #$06    ;ADD OFFSSETNOSIX  ADC #$3A    ;ADD OFFSET       RTS         ;RETURN;*********************************;  DISK ERROR CHECK;*********************************DISERR LDA #$08    ;DEV #8       STA FA      ;PUT IN DEV TABLE       JSR TALK    ;SEND TALK       LDA #$6F    ;SECONDARY ADDRESS       STA SA      ;PUT IN TABLE       JSR TALKSA  ;SEND SEC       JSR IECIN   ;GET FIRST BYTE       CMP #'0'    ;IS IT A ZERO       BNE DLOOC   ;IF NOT ZERO ERRORDLOOE  JSR IECIN   ;GET BYTE       CMP #$0D    ;IS IT CR?       BNE DLOOE   ;GET NEXT BYTE       JSR UNTALK  ;UNTALK       CLC         ;NO ERROR FLAG       RTS         ;RETURN;*********************************; PRINT DISK ERROR;*********************************DLOOC  PHA         ;STACK BYTE       JSR PRTCR   ;PRINT CR       PLA         ;GET BYTE       JSR CHROUT  ;PRINT ITDLOOA  JSR IECIN   ;GET NEXT BYTE       JSR CHROUT  ;PRINT IT       CMP #$0D    ;IS IT CR       BNE DLOOA   ;GET NEXT BYTE       JSR UNTALK  ;UNTALK       SEC         ;SET ERROR FLAG       RTS         ;RETURN;*********************************; STORAGE;*********************************NUMBYT .BYTE $AA   ;NUMBER BYTESCURBYT .BYTE $AA   ;CURRENT BYTE IN RECORDRECORD .WORD $AAAA ;RECORD NUMBERSTADD  .BYTE $AA   ;START ADDRESSCOUNT  .BYTE $AA   ;COUNTERTEMP   .BYTE $AA   ;TEMPOARYSCROPT .BYTE $AA   ;SCREEN OUPUT OPTION;*********************************COUNT1 .BYTE $AA    ;COUNTER;*********************************; ERROR MESSAGES;*********************************MSG1 .BYTE $0D,$8DMSG2 .BYTE $0D.BYTE 'BREAK',$8DMSG4 .BYTE $0D.BYTE 'BAD RECORD',$8DMSG5 .BYTE $0D.BYTE 'CHECKSUM ERRO',$D2MSG6 .BYTE $0D.BYTE 'FILE ERRO',$D2;*********************************; MESSAGES;*********************************MSG7 .BYTE $0D,$0D,$0D.BYTE 'OBJ2PRG.V20 V072882'.BYTE $0D.BYTE '(C)1982 BY COMMODORE'.BYTE $0D.BYTE 'BUSINESS MACHINES'.BYTE $8DMSG8 .BYTE $0D,$0D.BYTE 'OBJECT FILE NAME ?',$8DMSG9 .BYTE $0D,$0D.BYTE 'PRG NAME',$8DMSG11 .BYTE $0D,$0D.BYTE 'ADDRESS',$A0MSG12 .BYTE $0D.BYTE 'COUNT',$A0MSG13 .BYTE $0D.BYTE 'BYTE DATA',$8DMSG14 .BYTE $0D.BYTE 'CHECKSUM',$A0MSG15 .BYTE $0D.BYTE 'END OF FILE',$8DMSG16 .BYTE $0D.BYTE 'LAST RECORD',$8DMSG17 .BYTE $0D.BYTE 'FILE IS NON CONTIGUOUS',$8DMSG18 .BYTE $0D.BYTE 'PADDING FILE',$8D;*********************************; HEX DIGITS;*********************************DIGIT1 .BYTE $AADIGIT2 .BYTE $AADIGIT3 .BYTE $AADIGIT4 .BYTE $AA;*********************************; FILENAME NAME BUFFER;*********************************OUF .BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA;*********************************; FILENAME NAME BUFFER;*********************************PUF .BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA;*********************************; INIT DISK;*********************************INIT  .BYTE 'I0';*********************************OBJM  .BYTE ',S,R';*********************************PROGM .BYTE ',P,W';*********************************SAVO .BYTE $AASAVP .BYTE $AA;*********************************; CURRENT RECORD ADDRESS;*********************************RECLO .BYTE $AARECHI .BYTE $AA;*********************************; CURRENT ADDRESS AND DATA;*********************************ADDHI  .BYTE $AAADDLO  .BYTE $AACURDAT .BYTE $AA;*********************************; PADDING BYTES FOR NON-CONTIGUOS FILE;*********************************NUMPAD .WORD $0000PADBYT .BYTE $AA;*********************************; OUTPUT TO SCREEN OPTION;*********************************MSS1 .BYTE $0D,$0D .BYTE 'OUTPUT TO SCREEN' .BYTE $0D .BYTE '(Y OR N/CR)? ' .BYTE 0;*********************************; PADDING ERROR;*********************************MSE1 .BYTE $0D.BYTE 'PADDING NEGATIVE - PRG'.BYTE $0D.BYTE 'FILE INCOMPLETE',$0D.BYTE 0;*********************************; OUTPUT STRING ROUTINE;*********************************PRINT  STX COUNT   ;PUT X IN COUNTPLOOP  LDX COUNT   ;LOAD X FROM COUNT       LDA MSG1,X  ;LOAD CHAR       PHP         ;SAVE STATUS FLAG       AND #$7F    ;MASK BIT 8       JSR CHROUT  ;PRINT CHAR       INC COUNT   ;INC OFFSET       PLP         ;GET STATUS FLAG       BPL PLOOP   ;IF BIT 8 ZERO       RTS         ;RETURN;*********************************; OUTPUT UTILITIES;*********************************; STRING OUTPUT ROUTINE;*********************************STRPNT STA ZEROUR     ;POINTER TO       STY ZEROUR+1   ;MESSAGE       LDY #$00       ;OFFSETSOUT   LDA (ZEROUR),Y ;GET CHAR       BEQ SEXIT      ;IF ZERO EXIT       JSR CHROUT     ;PRINT       INY            ;INC OFFSET       BNE SOUT       ;LOOPSEXIT  RTS            ;RETURN;*********************************; INPUT UTILITIES;*********************************; GET OPTION (CR/Y OR N): Y=C=0;*********************************CRYS JSR CHRIN CMP #'Y' BEQ CRYS1 CMP #$0D BEQ CRYS1 BNE CRNO1;*********************************; GET OPTION (Y OR CR/N): Y=C=0;*********************************CRNO JSR CHRIN CMP #'N' BEQ CRNO1 CMP #$0D BEQ CRNO1CRYS1 CLC RTSCRNO1 SEC RTS;*********************************; INPUT STRING ROUTINE;*********************************INSTNO LDY #$00INSTN1 JSR CHRIN       STA OUF,Y       INY       CMP #$0D       BNE INSTN1       DEY       RTS;*********************************; INPUT STRING ROUTINE;*********************************INSTNP LDY #$00INSTN2 JSR CHRIN       STA PUF,Y       INY       CMP #$0D       BNE INSTN2       DEY       RTS;*********************************; OUTPUT CARRAIGE RETURN;*********************************PRTCR  LDA #$0D    ;ASCII CR       JMP CHROUT  ;PRINT IT;*********************************; ;*********************************INPUT = *       LDX #$07    ;FILE #7       JSR CHKIN   ;INPUT FILE       JSR CHRIN   ;INPUT CHAR       RTS;*********************************; OBJECT FILE IN NON-CONTIGUOUS; PAD PROGRAM FILE AS REQUIRE ;*********************************PADIT =*       LDX #MSG18-MSG1 ;OFFSET ADDRESS       JSR PRINT       ;PRINT HEADING;; CALUCLTE NUMBER OF BYTES TO PAD;       SEC             ;SUBTRACK       LDA ADDLO       ;EXPECTED ADDRESS       SBC RECLO       ;FROM RECORD       STA NUMPAD      ;ADDRESS TO       LDA ADDHI       ;DETERMINE       SBC RECHI       ;NUMBER OF BYTES       STA NUMPAD+1    ;TO PAD;; CHECK FOR NUMBER BYTES TO PAD NEGATIVE; THIS CAN HAPPEN IS RECORD ADDRESS IN LESS; THAN THE PREVIOUS ADDRESS RATHER THAN MORE; THE COMMODORE ASSEMBLER ALLOWS THESE KID OF; RECORDS TO BE CREATED AND THE LOADER PROGRAM; WILL JUST LOAD MEMORY ASS REQUIRED REGRADLESS; OF ITS SEQUENCE, BUT SINCE WE ARE BUILING A; CONTINUIOS PROGRAM FILE THAT FILES MEMORY FROM; THE START ADDRESS IN A LINEAR FASHION TO THE; END OF THE FILE, THERE IS NO WAY TO HANDLE THIS; CONDITION SO WE ABORT (FOR NOW - POSSIBLE IN; FUTURE THAT WE JUST IGNORE THIS RECORD AND WAIT; UNTIL ONE AHEAD IN MEMORY IS FOUND, BUT THIS MIGHT; LEAD TO OTHER ISSUES SUCH AS ITITLAIZED MEMORY THAT; IS NOT INCLUDED IN THE PRG FILE;; SIMPLE TEST. IF THE CARRY BIT IS STILL SET; THE SUBTRACTION LEAD TO A BARROW WHICH MEANS; THE NUMBER OF PADDING BYTE IS GREATER THAN; $FFFF AND HENCE IS NEGATIVE;       ;BCC DECPAD       BCS DECPAD       LDA #<MSE1  ;LOW BYTE MESSAGE       LDY #>MSE1  ;HIGH BYTE MESSAGE       JSR STRPNT  ;OUTPUT MESSAGE;       PLA         ;PULL RETURN ADDRESS OFF STACK       PLA         ;SO RTS IN ERROR ROUTINE IS TO                   ;BASIC AND NOT CALLER OF THIS                   ;ROUTINE       JMP PADERR;; DECREMENT PADDING BY ONE BYTE;DECPAD =*       LDA NUMPAD       BNE DECPA1       DEC NUMPAD+1DECPA1 DEC NUMPAD;; PRINT NUMBER OF BYTES TO PAD;       LDY NUMPAD+1    ;PRINT NUMBER       LDA NUMPAD      ;OF PADDING       JSR PRBYTS      ;BYTES       JSR PRTCR       ;NEW LINE;; CALCUALTE NEXT RECORD ADDRESS; AFTER PADDING;       CLC             ;ADD NUMBER OF       LDA RECLO       ;PADDED BYTES       ADC NUMPAD      ;TO PREVIOUS RECORD       STA RECLO       ;ADDRESS FOR NEXT       LDA RECLO+1     ;RECORD CHECK       ADC NUMPAD+1    ;       STA RECLO+1     ;;       CLC             ;INCREMENT       LDA RECLO       ;ADDRESS       ADC #$01        ;BY ONE       STA RECLO       ;TO ADVANCE PAST       LDA RECLO+1     ;PADDING TO NEXT       ADC #$00        ;ACTIVE ADDRESS       STA RECLO+1     ;;; PRINT WAHT NEXT RECORD ADDRESS SHOULD BE;       LDY RECLO+1     ;PRINT WHAT       LDA RECLO       ;NEXT RECORD       JSR PRBYTS      ;ADDRESS SHOULD BE       JSR PRTCR       ;NEW LINE;       JSR CLRCHN      ;RESET I/O        LDX #$08        ;FILE #8       JSR CHKOUT      ;SET TO OUTPUT;; WTITE OUT PADDING BYTES TO PRG FILE;PADIT1 =*       LDA PADBYT      ;PADDING BYTE       JSR CHROUT      ;WRITE IT TO FILE;       LDA NUMPAD       BNE PADIT2       LDA NUMPAD+1       BEQ PADIT3      ;KICKS IT OUT WHEN BOTH ARE 0       DEC NUMPAD+1PADIT2 DEC NUMPAD       CLC       BCC PADIT1;; RESET I/O AND WE ARE DONE; GO BACK AND HANDEL THE NON; CONTIGUIS RECORD THAT GOT US HERE;PADIT3 =*;       JSR CLRCHN  ;RESET I/O        LDX #$03    ;FILE #3       JSR CHKOUT  ;SET TO OUTPUT;       RTS;*********************************; PRINT UTILITES;*********************************; PRINT WORD MSB IN Y LSB IN A;*********************************PRBYTS PHA       ;PUT A ON STACK       TYA       ;PUT HIH BYTE IN A       JSR PRBYT ;PRINT MSB       PLA       ;GET LSB;*********************************; PRINT BYTE IN A;*********************************PRBYT  PHA        ;PUT BYTE ON STACK       LSR A      ;4 RIGHT SHIFTS       LSR A      ;TO MOVE HIGH       LSR A      ;NIBBLE TO LOW       LSR A      ;NIB WITH HIGH 0'S       TAY        ;USE AS POINTER       LDA HEXA,Y ;GET ASCII       JSR CHROUT ;PRINT       PLA        ;PULL BYTE OUT       AND #$0F   ;MASK HIGH NIBBLE       TAY        ;USE AS POINTER       LDA HEXA,Y ;GET ASCII       JMP CHROUT ;PRINT;*********************************; HEX-TO-ASCII TABLE;*********************************HEXA   .BYTE '0123456789ABCDEF';*********************************; CURRENT RECORD HOLDING BUFFER;*********************************DATA .BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA.BYTE $AA,$AA,$AA,$AA,$AA,$AA;*********************************;.END