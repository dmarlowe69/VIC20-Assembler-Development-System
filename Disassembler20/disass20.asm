;.PAGE 'DISASSEMBLER20';.OPT LIST;**********************************=$1201        ;START OF BASIC WITH 32K RAM EX;*********************************; SET BSTUB TO ONE TO ALLOW FOR; INSERTION OF BASIC STUB CODE;*********************************BSTUB = 1;*********************************;;        DISASSEMBLER20;    DISASSEMBLER.V20 V080282;    SYMBOLIC DISASSEMBLER;       BY DENTON MARLOWE;;  (C)1986 BY DENTON MARLOWE;; MACRO ASSEMBLER DEVELOPMENT SYSTEM;  (C) 1982 BY COMMODORE MACHINES;;*********************************;; BASIC FORMAT PROGRAM;; 10 SYS(4623);;*********************************;.IFN BSTUB <.IF  BSTUB == 1 .WORD BASIC ;NEXT LINE POINTER .BYTE $0A,$00 ;LINE NUMBER .BYTE $9E ;SYS COMMAND .TEXT '(4623)' ;ASCII (2063) .BYTE 0 ;END OF LINEBASIC .BYTE 0,0 ;END OF BASIC;>.FI;*********************************;.INCLUDE "dis.asm";*********************************;.INCLUDE "option.asm";*********************************;.INCLUDE "util.asm";*********************************;.INCLUDE "mode.asm";*********************************;.INCLUDE "internal.asm";*********************************;.INCLUDE "asc.asm";*********************************;.INCLUDE "table.asm";*********************************;.INCLUDE "sym.asm";*********************************;.END;*********************************; FILE DIS.ASM;*********************************;;        DISASSEMBLER64;    SYMBOLIC DISASSEMBLER;       BY DENTON MARLOWE;;  (C)1986 BY DENTON MARLOWE;;*********************************; KERNAL ADDRESS;*********************************VICREG=$900F ;C64 = $D011 SCREEN REGISTERCHROUT=$FFD2 ;OUTPUT CHARACTERCHKIN =$FFC6 ;OPEN INPUT FILECHRIN =$FFCF ;GET KEYBOARD INPUTGETIN =$FFE4 ;GET KEYBOARD CHARCLRCHN=$FFCC ;RESET I/O CHANNELSSTOP =$FFE1 ;CHECK FOR STOPREADST=$FFB7 ;READ STSETNAM=$FFBD ;SET FILENAMESETLFS=$FFBA ;SET LOGICAL FILEOPEN =$FFC0 ;OPEN FILECHKOUT=$FFC9 ;OPEN OUTPUT CHANNELCLOSE =$FFC3 ;CLOSE LOGICAL FILEWREADY=$C474 ;$E391 = $A474 BASIC RETURNZEROUR=$02 ;ZEROPAGE POINTERMEMSIZ=$37 ;TOP OF FREE RAM+1;*********************************;        ENTRY POINT;*********************************STARTD JMP DISASS;*********************************;       VARIABLES;*********************************PASS  .BYTE '1'  ;PASS INDICATORIPASS .BYTE '1'  ;INTERNAL PASSEPASS .BYTE '2'  ;EXTERNAL PASSCPASS .BYTE '3'  ;PRINTING PASSSPASS .BYTE '4'  ;SYMBOL PASS;*********************************XOPT .BYTE $AA ;LABEL GENERATIONROPT .BYTE $AA ;REL ADDRESS OPTDEVICE .BYTE $AA ;OUTPUT DEVICEOUTPUT .BYTE $AA ;OUTPUT FLAGWINDOW .BYTE $AA ;WINDOW FLAGFOROPT .BYTE $AA ;FORMAT FLAGCOMOPT .BYTE $AA ;COMMENT FLAG;*********************************; DISASSEMBLY ADDRESS POINTERS;*********************************SA .WORD $AAAA ;START ADDRESSEA .WORD $AAAA ;END ADDRESSSELECT .WORD $AAAA ;BYTE POINTEROFFSET .WORD $AAAA ;ADDRESS OFFSETSAGOL  .WORD $AAAA ;GOLBAL STARTEAGOL  .WORD $AAAA ;GOLBAL ENDSAOUT .WORD $AAAA ;START ADDRESSEAOUT .WORD $AAAA ;END ADDRESS;*********************************; INTERNAL ADDRESS TABLE;*********************************TABINP .WORD $AAAA ;TABLE POINTERTABINS .WORD $AAAA ;TABLE STARTTABINE .WORD $AAAA ;TABLE END;*********************************; SORT TABLE POINTERS;*********************************SMALLS .WORD $AAAA ;TABLE STARTSMALLP .WORD $AAAA ;TABLE POINTER;*********************************; SYMBOL TABLE;*********************************SYMBOL .BYTE $AA   ;SYMBOL OPTIONSYMBOP .WORD $AAAA ;TABLE POINTERSYMBOS .WORD $AAAA ;TABLE STARTSYMBOE .WORD $AAAA ;TABLE END;*********************************; UNDEFINED SYMBOL TABLE;*********************************UYMBOP .WORD $AAAA ;TABLE POINTERUYMBOS .WORD $AAAA ;TABLE STARTUYMBOE .WORD $AAAA ;TABLE END;*********************************; TEMP WORKING STORAGE;*********************************WORKED .WORD $AAAA ;TWO BYTE OPWORKER .WORD $AAAA ;TWO BYTE OPSAVEP .WORD $AAAA ;TWO BYTE OPSAVES .WORD $AAAA ;TWO BYTE OPSAVEE .WORD $AAAA ;TWO BYTE OP;*********************************; OTHER VARIABLES;*********************************ADRS .WORD $AAAATEMP .BYTE $AASAVA .BYTE $AASAVX .BYTE $AASAVY .BYTE $AA;*********************************; PRINTER OUTPUT STORAGE;*********************************PAGECT .WORD $AAAA ;PAGE COUNTLISTCT .BYTE $AA ;LINE COUNTLINECT .WORD $AAAA ;LINE COUNTERRCT  .WORD $AAAA ;ERROR COUNT;*********************************; INPUT BUFFER;*********************************BUF = * .BYTE 0,0,0,0,0,0,0,0,0,0 .BYTE 0,0,0,0,0,0,0,0,0,0 .BYTE 0,0,0,0,0,0,0,0,0,0 .BYTE 0,0,0,0,0,0,0,0,0,0 .BYTE 0,0,0,0,0,0,0,0,0,0 .BYTE 0,0,0,0,0,0,0,0,0,0 .BYTE 0,0,0,0,0,0,0,0,0,0 .BYTE 0,0,0,0,0,0,0,0,0,0 .BYTE 0,0,0,0,0,0,0,0,0,0 .BYTE 0,0,0,0,0,0,0,0,0,0;*********************************; FILE NAME BUFFER;*********************************LINEFL .WORD $AAAAVERSON .BYTE $AANCHARS .BYTE $AANBUF = * .TEXT '0:' .BYTE $AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA .BYTE $AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA .BYTE $AA,$AA,$AA,$AA;*********************************; SYMBOL TABLE BUFFER;*********************************SYMBUF = * .BYTE $AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA,$AA;*********************************; DATA TABLE;*********************************EAS .WORD $AAAATEXTER .BYTE $AACDATA .WORD $AAAANDATA .WORD $AAAADATABP .WORD $AAAA ;DATA POINTDATABS .WORD $AAAA ;DATA STARTDATABE .WORD $AAAA ;DATA END;*********************************; DATA TABLE;*********************************TDATA .BYTE $AA;**********************************=*+$0100;*********************************MPASS  .TEXT $0D,$0D,'PASS',0PMSG   .TEXT $0D,$12,' PAUSE ',$92,$0D,0MSGERR .TEXT 'ERRORS = ',0MSGDIS .TEXT 'END OF DISASSEMBLY',0;*********************************; INITIALIZE DISASSEMBLER;*********************************DISASS LDX #$FF TXS CLD JSR DOP ;GET OPTIONS JSR INITIN ;INIT POINTERS LDA #'1'      ;PASS ONE STA PASS ;SET PASS INDICATOR;*********************************; DISASSEMBLER LOOP;*********************************DISA JSR INTSA ;SET SA LDA #00 ;ZERO BYTE STA CDATA ;SET TABLE NUMBER LDA #<MPASS ;PASS MSG LDY #>MPASS ; JSR STRPNT ;PRINT IT LDA PASS ;GET PASS JSR PCHAR ;PRINT NUMBER JSR CRLF ;CR;********************************* LDA PASS ;GET PASS CMP CPASS ;IS IT LAST BEQ DISB ;IF SO PRINT CMP EPASS      ;IS IT EXTERNAL BNE DLOOP ;IF NOT GO ON JSR SAVINT ;SAVE INTERNAL JSR EQUINT ;SET EQUATES JMP DLOOP ;GO ON;*********************************DISB LDA #$01 ;ONE BYTE STA LINECT ;SET LINE # TO 1 STA PAGECT ;SET PAGE TO 1 LDA #$00 ;ZERO BYTE STA LINECT+1 ;SET LINE # TO 1 STA PAGECT+1 ;SET PAGE TO 1 STA LISTCT ;SET LIST TO 0 STA ERRCT ;SET ERROR TO 0 STA ERRCT+1 ;SET ERROR TO 0 STA LINEFL ;SET LINE TO 0 STA LINEFL+1 ;SET LINE TO 0 LDA OUTPUT ;GET OUTPUT STA DEVICE ;SET OUTPUT;********************************* JSR HEADER ;PRINT HEADER JSR OFILED ;OPEN DISK FILE JSR ORGIN ;PRINT ORGIN LABEL JSR EQUPRT ;PRINT EQUATE;********************************DLOOP JSR DSLINE ;DIS ONE LINE BCS NEXTP ;IF EA STOP JSR LINECK ;LINE COUNT JSR STOP ;CHECK STOP BEQ QUITS ;IF SO QUIT JSR GETIN ;GET KEY BEQ DLOOP ;IF NONE NEXT CMP #' '          ;IS IT A SPACE BNE DLOOP ;IF NOT NEXT;*********************************; PAUSE LISTING;******************************** LDA DEVICE PHA LDA #$03 STA DEVICE LDA #<PMSG LDY #>PMSG JSR STRPNT PLA STA DEVICEPAUSE JSR GETIN ;PAUSE FOR KEY BEQ PAUSE ; BNE DLOOP ;NEXT LINE;********************************NEXTP INC PASS ;INC PASS LDA PASS ;GET PASS CMP CPASS ;LAST PASS? BCC DISFUL ;IF LESS AGAIN BNE DISC ;FINISH LDA WINDOW ;WINDOW FLAG BEQ DISFUL ;FULL OUTPUT;*********************************; WINDOWED OUTPUT;********************************* LDA SAOUT ; STA SA ; LDA SAOUT+1 ; STA SA+1 ; LDA EAOUT ; STA EA ; LDA EAOUT+1 ; STA EA+1 ;;*********************************DISFUL JMP DISA ;LAST PASSDISC JSR INCSL JSR EFILE ;END FILE MSG;*********************************QUITS LDA DEVICE ;CHECK DEV AND #$08 ;DISK FILE? BEQ QUTERR ;IF NOT BRANCH LDA #$08 ;DISK JSR CLOSE ;CLOSE IT LDA OUTPUT ;GET OUTPUT AND #07 ;MASK DISK STA OUTPUT ;RESET OUTPUT STA DEVICE ;RESET OUTPUT;*********************************; PRINT ERRORS;*********************************QUTERR LDA OUTPUT ORA #$03 STA OUTPUT STA DEVICE JSR NEWLIN JSR NEWLIN LDA #<MSGERR LDY #>MSGERR JSR STRPNT LDX ERRCT LDA ERRCT+1 JSR PRTNUM;********************************* LDA DEVICE ;CHECK DEV AND #$04 ;PRINTER? BEQ DONED ;IF NOT DONE LDA #$04 ;DEVICE 4 STA OUTPUT ;SET DEVICE STA DEVICE ;SET DEVICE JSR INTPRT ;PRINT INTABLE LDA #$07 ;DEVICE 3 AND 4 STA DEVICE ;SET DEVICE STA OUTPUT ;SET DEVICEDONED JSR NEWLIN ;NEWLINE JSR NEWLIN ;NEWLINE LDA #<MSGDIS ;END MSG LDY #>MSGDIS JSR STRPNT ;PRINT IT JSR NEWLIN ;NEW LINE LDA DEVICE ;CHECK DEVICE AND #$04 ;PRINTER BEQ DONE ; JSR FINISH ;FINISH PAGE LDA #$04 ;PRINTER JSR CLOSE ;CLOSE FILE;*********************************DONE JSR CLRCHN ;RESET I/O JSR SCRON      ;TURN SCREEN ON JMP WREADY     ;RETURN;*********************************;.FIL 0:OPTION.ASM;*********************************;.END;*********************************; FILE OPTION.ASM;*********************************;;        DISASSEMBLER64;    SYMBOLIC DISASSEMBLER;       BY DENTON MARLOWE;;  (C)1986 BY DENTON MARLOWE;;*********************************; DISASSEMBLER OPTIONS;*********************************DOP LDA #$03 ;DEVICE #3 SCREEN STA DEVICE ;CURRENT OUTPUT LDA #$00 ;NO DEVICES STA OUTPUT ;FINAL OUTPUT LDA #<MSG ;START UP MSG LDY #>MSG JSR STRPNT ;PRINT IT;*********************************; READ IN DISK FILE ?;********************************* LDA #<MSF1 LDY #>MSF1 JSR STRPNT JSR INSTNG BNE PFILE0 JMP STARTSPFILE0 LDX #$00PFILE1 LDA PROGM,X STA BUF,Y INY INX CPX #$04 BNE PFILE1 STY SAVA JSR INITD JSR PRFILE;*********************************; READ IN FILE FOR SA AND EA;********************************* LDX #$08 ;FILE #8 JSR CHKIN ;INPUT FILE JSR CHRIN ;GET LOW BYTE SA STA SA ;SET START JSR CHRIN ;GET HIGH BYTE SA STA SA+1 ;SET START JSR INTSA ;SET END;********************************* LDA #$00 ;ZERO BYTE STA ADRS ;BYTE COUNTER STA ADRS+1 ;BYTE COUNTERPROGRD JSR CHRIN ;INPUT BYTE JSR READST ;READ STATUS BNE PROGED ;IF NOT ZERO END JSR INCSL ;INC END ADDRESS INC ADRS ;INC BYTE COUNT BNE *+5 ; INC ADRS+1 ; BNE PROGRD ;NEXT BYTEPROGED LDA SELECT ; STA EA ; LDA SELECT+1 ; STA EA+1 ;;********************************* LDA #$08 ;FILE #8 JSR CLOSE ;CLOSE IT JSR CLRCHN ;RESET I/O;*********************************; PRINT PROGRAM LOAD ADDRESS; AND END ADDRESS;********************************* LDA #<MSF2 LDY #>MSF2 JSR STRPNT LDA SA STA WORKED LDA SA+1 STA WORKED+1 JSR PWORKD; LDA #'-'; JSR PCHAR JSR DOLLAR JSR PSELEC JSR CRLF;*********************************; CALCULATE BUFFER ADDRESS;********************************* LDA MEMSIZ STA SELECT LDA MEMSIZ+1 STA SELECT+1 JSR DECSL SEC LDA SELECT SBC ADRS STA SELECT LDA SELECT+1 SBC ADRS+1 STA SELECT+1;*********************************; CALCULATE ADDRESS OFFSET;********************************* SEC LDA SELECT SBC SA STA OFFSET STA WORKED LDA SELECT+1 SBC SA+1 STA OFFSET+1 STA WORKED+1 LDA #<MSD4A LDY #>MSD4A JSR STRPNT JSR PWORKD JSR CRLF;*********************************; OPEN FILE AND READ PRG INTO BUF;********************************* JSR PRFILE ;OPEN FILE LDX #$08 ;FILE #8 JSR CHKIN ;INPUT FILE JSR CHRIN ;GET LOW BYTE SA JSR CHRIN ;GET HIGH BYTE SAPRO2RD JSR CHRIN ;INPUT BYTE LDX SELECT ;LOW BYTE POINTER STX ZEROUR ;ZERO PAGE LDX SELECT+1 ;HIH BYTE POINTER STX ZEROUR+1 ;ZERO PAGE LDY #$00 ;OFFSET STA (ZEROUR),Y ;STORE BYTE JSR INCSL ;INC POINTER JSR READST ;READ STATUS BEQ PRO2RD ;NEXT BYTE LDA #$08 ;FILE #8 JSR CLOSE ;CLOSE IT JSR CLRCHN ;RESET I/O JMP WINDOP ;WINDOW OPTION;*********************************; OPEN PROGRAM FILE;*********************************PRFILE LDA SAVA LDX #<BUF LDY #>BUF JSR SETNAM LDA #$08 TAY TAX JSR SETLFS JSR OPEN JSR DISERR BCC PROGOK LDA #$08 JSR CLOSE PLA PLA PLA PLA JMP WREADY;*********************************PROGOK RTS;*********************************; INIT DISK;*********************************INITD LDA #$02 LDY #>INIT LDX #<INIT JSR SETNAM LDA #$0F LDX #$08 LDY #$0F JSR SETLFS JSR OPEN LDA #$0F JMP CLOSE;*********************************; GET START ADDRESS;*********************************STARTS LDA #<MSD1 LDY #>MSD1 JSR STRPNT JSR GETWRD LDA ADRS STA SA LDA ADRS+1 STA SA+1;*********************************; GET END ADDRESS;********************************* LDA #<MSD2 LDY #>MSD2 JSR STRPNT JSR GETWRD LDA ADRS STA EA LDA ADRS+1 STA EA+1;*********************************; ADDRRESS OFFSET;********************************* LDA #<MSD4 LDY #>MSD4 JSR STRPNT JSR GETWRD LDA ADRS STA OFFSET LDA ADRS+1 STA OFFSET+1;*********************************; OUTPUT WINDOW;*********************************WINDOP LDA #<MSD5 LDY #>MSD5 JSR STRPNT JSR CRNO BCS WIND1 LDA #<MSD1 LDY #>MSD1 JSR STRPNT JSR GETWRD LDA ADRS STA SAOUT LDA ADRS+1 STA SAOUT+1 LDA #<MSD2 LDY #>MSD2 JSR STRPNT JSR GETWRD LDA ADRS STA EAOUT LDA ADRS+1 STA EAOUT+1 LDA #$FF BMI WIND2WIND1 LDA #$00WIND2 STA WINDOW;*********************************; SETUP GOBAL POINTER;********************************* LDA SA STA SAGOL LDA SA+1 STA SAGOL+1 LDA EA STA EAGOL LDA EA+1 STA EAGOL+1;*********************************; SOURCE FILE OUTPUT?;*********************************OUFILE LDA #<MSG1 LDY #>MSG1 JSR STRPNT;********************************* LDA #$00 STA NCHARS JSR INSTNG BEQ NOFILE LDA #'0' STA VERSON STY NCHARS LDX #$00GFILE0 LDA BUF,X STA NBUF,X INX CPX NCHARS BNE GFILE0;*********************************FILEOK LDA #$08 BNE FILENOFILE LDA #$00FILE ORA OUTPUT STA OUTPUT JMP PRTGET;*********************************;     OPEN SOURCE DISK FILE;*********************************OFILED LDY NCHARS BEQ NOID JSR INITDNOID JSR SCROFF;*********************************OFILE LDY NCHARS BEQ OFILE4 LDA VERSON CMP #'0' BEQ OFILE1 LDA VERSON STA NBUF,Y INYOFILE1 INC VERSON LDX #$00OFILE2 LDA WRITE,X STA NBUF,Y INY INX CPX #$04 BNE OFILE2 TYA LDY #>NBUF LDX #<NBUF JSR SETNAM LDA #$08 TAX TAY JSR SETLFS JSR OPEN JSR DISERR BCC OFILE4;*********************************;  CLOSE OUT FILE ON ERROR;*********************************OFILE3 LDA #$08 JSR CLOSE JSR CLRCHN PLA PLA PLA PLA JMP WREADYOFILE4 RTS;*********************************; GET PRINTER OPTION;*********************************PRTGET LDA #<MSG2 LDY #>MSG2 JSR STRPNT JSR CRYS BCS NOPRT LDA #$00 JSR SETNAM LDA #$04 LDX #$04 LDY #$00 JSR SETLFS JSR OPEN LDX #$04 JSR CHKOUT JSR READST AND #$80 PHP JSR CLRCHN PLP BMI NOPRT LDA #$04 BNE PRINTNOPRT LDA #$03PRINT ORA OUTPUT STA OUTPUT;*********************************; GO GET SYMBOLIC OPTION;*********************************       JSR SOP;*********************************; GET RELATIVE ADDRESS OPTION;*********************************       LDA #<MSR1       LDY #>MSR1       JSR STRPNT       JSR CRYS       BCC DOP2       LDA #$01       BNE DOP3DOP2   LDA #$00DOP3   STA ROPT;*********************************; GET BIT INSTRUCTION CODING OPTION;*********************************       JSR BITOPT;*********************************; DATA TABLE OPTION;*********************************AOP LDA SYMBOE STA DATABP STA DATABS STA DATABE STA ZEROUR LDA SYMBOE+1 STA DATABP+1 STA DATABS+1 STA DATABE+1 STA ZEROUR+1;********************************* LDA #<MSAOP LDY #>MSAOP JSR STRPNT JSR INSTNG BNE BOP JMP NOTABS;*********************************BOP TYA PHA JSR INITD PLA TAY LDX #$00AFILE LDA NAMS,X STA BUF,Y INY INX CPX #$04 BNE AFILE TYA LDY #>BUF LDX #<BUF JSR SETNAM LDA #$03 LDX #$08 LDY #$03 JSR SETLFS JSR OPEN JSR DISERR BCS AGET1 LDX #$03 JSR CHKIN;*********************************; READ IN DATA TABLE;********************************* LDY #$00 JSR CHRIN STA NDATA BEQ AGET1AGET JSR CHRIN STA TDATA,Y INY JSR READST BEQ AGETAGET1 LDA #$03 JSR CLOSE JSR CLRCHN;*********************************; PRINT DATA TABLE;*********************************PRTDAS LDA NDATA STA CDATA LDY #$00 STY SAVYPRTNEX JSR CRLF LDX #$05 STX SAVXPRTDAL LDY SAVY LDA TDATA,Y JSR PRBYT JSR SPACE INC SAVY DEC SAVX BNE PRTDAL DEC CDATA BNE PRTNEX;********************************* JMP XOP0;*********************************; READ DATA FOR KEYBOARD;*********************************NOTABS LDA #<MSA1 ;NUMBER OF DATA LDY #>MSA1 JSR STRPNT JSR GETWRD ;INPUT HEX BYTE LDA ADRS ;GET BYTE STA NDATA ;SET NUM TABLES BNE AOPX ;0 DATA THEN END JMP XOP0 ;RETURNAOPX LDA #$00 ;ZERO OFFSET STA CDATA ;FIRST TABLE;*********************************; CALCULATE TABLE OFFSET;*********************************AOP1 LDA CDATA ;GET TABLE NUMBER ASL A ;*2 ASL A ;*4 CLC ;C=0 ADC CDATA ;*5 STA SAVY ;STORE AS OFFSET;********************************* LDA #<MSA2 LDY #>MSA2 JSR STRPNT ;PRINT MSG JSR GETWRD ;GET ADDRESS LDY SAVY ;GET OFFSET LDA ADRS STA TDATA,Y INY LDA ADRS+1 STA TDATA,Y INY STY SAVY;*********************************; END OF DATA TABLE;*********************************AOP2 LDA #<MSA3 LDY #>MSA3 JSR STRPNT JSR GETWRD ;GET ADDRESS LDY SAVY LDA ADRS STA TDATA,Y INY LDA ADRS+1 STA TDATA,Y INY STY SAVY;*********************************; GET TYPE OF TABLE;********************************* LDA #<MSG5 ;TABLE TYPE LDY #>MSG5 JSR STRPNTAOP3 JSR GETIN BEQ AOP3 CMP #'0' BEQ ASC CMP #'1' BEQ ASC CMP #'2' BEQ ASC CMP #'3' BEQ ASC CMP #'4' BEQ ASC CMP #'S' BNE AOP3ASC JSR CHROUT LDY SAVY STA TDATA,Y;********************************* INC CDATA ;INC TABLE COUNT LDA CDATA ;GET TABLE COUNT CMP NDATA ;ALL TABLES? BEQ XOP0 ;IF NOT GET MORE JMP AOP1 ;IF NOT GET MORE;*********************************; GET LABEL GENERATION OPTION;*********************************XOP0 LDA #<MSB4 LDY #>MSB4 JSR STRPNT JSR CRYS BCS XOP1 LDA #$01 BNE XOP2XOP1 LDA #$00XOP2 STA XOPT;*********************************; OUTPUT FORMAT OPTION;********************************* LDA #<MSB5 LDY #>MSB5 JSR STRPNT JSR CRYS BCS FOP1 LDA #$00 BEQ FOP2FOP1 LDA #$FFFOP2 STA FOROPT;********************************* RTS;*********************************;   COMMAND MESSAGES;*********************************MSG .BYTE $93 ;CLEAR SCREEN .BYTE $0D,$0D.TEXT 'CBM RESIDENT'.BYTE $0D.TEXT 'DISASSEMBLER'.BYTE $0D.TEXT 'V080282'.BYTE $0D.TEXT '(C)1982 COMMODORE'.BYTE $0D.TEXT 'BUSINESS MACHINES'.BYTE $0D.BYTE 0;*********************************MSF1 .BYTE $0D.TEXT 'PROGRAM FILE'.BYTE $0D.TEXT '(CR OR NAME):'.BYTE 0;*********************************MSF2 .BYTE $0D.BYTE $0D.TEXT 'PROGRAM ADDRESS:'.BYTE $0D.BYTE '$'.BYTE 0;*********************************MSG1 .BYTE $0D.BYTE $0D.TEXT 'EDITOR64 FILE'.BYTE $0D.TEXT '(CR OR NAME):'.BYTE 0;*********************************WRITE .TEXT ',S,W'PROGM .TEXT ',P,R'INIT  .TEXT 'I0';*********************************MSG2 .BYTE $0D.BYTE $0D.TEXT 'HARD COPY'.BYTE $0D.TEXT '(Y/CR OR N)? '.BYTE 0;*********************************MSD1 .BYTE $0D.TEXT 'START ADDRESS :$'.BYTE 0;*********************************MSD2 .BYTE $0D.TEXT 'END ADDRESS :$'.BYTE 0;*********************************MSD4 .BYTE $0D.TEXT 'ADDRESS OFFSET (OR CR):$'.BYTE 0;*********************************MSD4A .BYTE $0D.TEXT 'ADDRESS OFFSET :$'.BYTE 0;*********************************MSD5 .BYTE $0D.TEXT 'WINDOW OUTPUT'.BYTE $0D.TEXT '(Y OR N/CR)? '.BYTE 0;*********************************MSR1 .BYTE $0D.BYTE $0D.TEXT 'RELATIVE BRANCH'.BYTE $0D.TEXT 'TO LABEL'.BYTE $0D.TEXT '(Y/CR OR N)? '.BYTE 0;*********************************MSB1 .BYTE $0D .TEXT 'BIT INSTRUCTION CODING' .BYTE $0D,$0D .TEXT '0/CR STD',$0D .TEXT '1 $2C',$0D .TEXT '2 $24',$0D .TEXT '3 $2C & $24',$0D .BYTE $0D .TEXT 'ENTER BIT CODE: ' .BYTE 0;*********************************MSAOP .BYTE $0D.TEXT 'DATA TABLE FILE (CR OR NAME):'.BYTE 0MSA1 .BYTE $0D.BYTE $0D.TEXT 'NUMBER OF DATA TABLES'.BYTE $0D.TEXT '(OR CR) :$'.BYTE 0MSA2 .BYTE $0D.BYTE $0D.TEXT 'TABLE START ADDRESS'.BYTE $0D.TEXT ':$'.BYTE 0MSA3 .BYTE $0D.BYTE $0D.TEXT 'TABLE END ADDRESS'.BYTE $0D.TEXT ':$'.BYTE 0MSG5 .BYTE $0D,$0D .TEXT 'DISASSEMBLY' .BYTE $0D .TEXT 'OPTIONS' .BYTE $0D,$0D .TEXT '0 ASCII',$0D .TEXT '1 BYTE',$0D .TEXT '2 WORD',$0D .TEXT '3 DBYTE',$0D .TEXT '4 WORD-1',$0D .TEXT 'S SKIP ADDRESS RANGE',$0D .TEXT 'ENTER DISASSEMBLY' .BYTE $0D .TEXT 'CODE: ' .BYTE 0;*********************************MSB4 .BYTE $0D.BYTE $0D.TEXT 'LABLE GENERATION'.BYTE $0D.TEXT '(Y/CR OR N)? '.BYTE 0;*********************************MSB5 .BYTE $0D.BYTE $0D.TEXT 'FORMATED LISTING'.BYTE $0D.TEXT '(Y/CR OR N)? '.BYTE 0;*********************************;.FIL 0:UTIL.ASM;*********************************;.END;*********************************; FILE UTIL.ASM;*********************************;;        DISASSEMBLER64;    SYMBOLIC DISASSEMBLER;       BY DENTON MARLOWE;;  (C)1986 BY DENTON MARLOWE;;*********************************;      *** UTILITIES ***;*********************************; CHECK LINE COUNT FOR OUTPUT FILE;*********************************LINECK LDA PASS CMP CPASS BNE LINECO LDA DEVICE AND #$08 BEQ LINECO;*********************************; CLOSE SOURCE FILE AND OPEN NEXT;********************************* SEC LDA LINEFL SBC #$20 STA TEMP LDA LINEFL+1 SBC #$03 ORA TEMP BCC LINECO NOP NOP NOP JSR EFILE LDA #$08 JSR CLOSE JSR OFILE LDA #$00 STA LINEFL STA LINEFL+1 JSR ORGIN JSR COMENTLINECO RTS;*********************************;  DISK ERROR CHECK;*********************************DISERR LDA #$08 ;DEV #8 STA $BA ;PUT IN DEV TABLE JSR $FFB4 ;SEND TALK LDA #$6F ;SECONDARY ADDRESS STA $B9 ;PUT IN TABLE JSR $FF96 ;SEND SEC JSR $FFA5 ;GET FIRST BYTE CMP #$30 ;IS IT A ZERO BNE DLOOC ;IF NOT ZERO ERRORDLOOE JSR $FFA5 ;GET BYTE CMP #$0D ;IS IT CR? BNE DLOOE ;GET NEXT BYTE JSR $FFAB ;UNTALK CLC ;NO ERROR FLAG RTS ;RETURN;*********************************; PRINT DISK ERROR;*********************************DLOOC PHA ;STACK BYTE LDA #$0D ;ASCII CR JSR CHROUT ;PRINT IT PLA ;GET BYTE JSR CHROUT ;PRINT ITDLOOA JSR $FFA5 ;GET NEXT BYTE JSR CHROUT ;PRINT IT CMP #$0D ;IS IT CR BNE DLOOA ;GET NEXT BYTE JSR $FFAB ;UNTALK SEC ;SET ERROR FLAG RTS ;RETURN;*********************************; START NEW LINE AND INC COUNT;*********************************NEWLIN INC LINECT BNE *+5 INC LINECT+1 INC LINEFL BNE *+5 INC LINEFL+1 JSR CRLF LDA DEVICE AND #$04 BEQ NEWEXT JSR NEXLINNEWEXT RTS;*********************************; INPUT UTILITIES;*********************************; INPUT STRING ROUTINE;*********************************INSTNG LDY #$00INSTN1 JSR CHRIN STA BUF,Y INY CMP #$0D BNE INSTN1 DEY RTS;*********************************; INPUT HEX CHAR STRING;*********************************GETWRD LDA #$00 STA ADRS STA ADRS+1 JSR INSTNG DEY BMI INEND;*********************************; PROCESS INPUT;********************************* JSR GETBYT LDA TEMP STA ADRS DEY BMI INEND JSR GETBYT LDA TEMP STA ADRS+1INEND RTS;*********************************; COVERT BUFFER INTO BYTES;*********************************GETBYT LDA BUF,Y JSR BINARY STA TEMP DEY BMI INENX LDA BUF,Y JSR BINARY ASL A ASL A ASL A ASL A ORA TEMP STA TEMPINENX RTS;*********************************; CONVERT A INTO HEX NIBBLE;*********************************BINARY SEC SBC #'0' BCC NOHEX CMP #$0A BCC YSHEX SBC #$07 CMP #$10 BCS NOHEX CMP #$0A BCS YSHEXNOHEX SEC RTSYSHEX CLC RTS;*********************************; GET OPTION (CR/Y OR N): Y=C=0;*********************************CRYS   JSR CHRIN       CMP #'Y'       BEQ CRYS1       CMP #$0D       BEQ CRYS1       BNE CRNO1;*********************************; GET OPTION (Y OR CR/N): Y=C=0;*********************************CRNO   JSR CHRIN       CMP #'N'       BEQ CRNO1       CMP #$0D       BEQ CRNO1CRYS1  CLC       RTSCRNO1  SEC       RTS;*********************************; PRINT UTILITES;*********************************; PRINT WORD MSB IN Y LSB IN A;*********************************PRBYTS PHA ;PUT A ON STACK TYA ;PUT HIH BYTE IN A JSR PRBYT ;PRINT MSB PLA ;GET LSB;*********************************; PRINT BYTE IN A;*********************************PRBYT PHA ;PUT BYTE ON STACK LSR A ;4 RIGHT SHIFTS LSR A ;TO MOVE HIGH LSR A ;NIBBLE TO LOW LSR A ;NIB WITH HIGH 0'S TAY ;USE AS POINTER LDA HEXA,Y ;GET ASCII JSR PCHAR ;PRINT PLA ;PULL BYTE OUT AND #$0F ;MASK HIGH NIBBLE TAY ;USE AS POINTER LDA HEXA,Y ;GET ASCII JMP PCHAR ;PRINT;*********************************; STRING OUTPUT ROUTINE;*********************************STRPNT STA ZEROUR ;POINTER TO STY ZEROUR+1 ;MESSAGE LDY #$00 ;OFFSETSOUT LDA (ZEROUR),Y ;GET CHAR BEQ SEXIT ;IF ZERO EXIT JSR PCHAR ;PRINT INY ;INC OFFSET BNE SOUT ;LOOPSEXIT RTS ;RETURN;*********************************; PRINT DEC NUMBER (0000);*********************************PRTPAG STX ZEROUR ;LOW  BYTE NUM STA ZEROUR+1 ;HIGH BYTE NUM LDX #$03 ;4 CHARS STX SAVX ;SAVE COUNT BNE PRTNU1 ;BRANCH;*********************************; PRINT DEC NUMBER (00000);*********************************PRTNUM STX ZEROUR ;LOW  BYTE NUM STA ZEROUR+1 ;HIGH BYTE NUM LDX #$04 ;5 CHARS STX SAVX ;SAVE COUNT;*********************************; PRINT DEC NUMBER AND LEADING 0;*********************************PRTNU1 LDX SAVX LDY #$30 BNE PRTNU3PRTNU2 INY PRTNU3 SEC  LDA ZEROUR SBC CONST0,X STA ZEROUR LDA ZEROUR+1 SBC CONST1,X STA ZEROUR+1 BCS PRTNU2 LDA ZEROUR ADC CONST0,X STA ZEROUR LDA ZEROUR+1 ADC CONST1,X STA ZEROUR+1 TYA JSR PCHAR DEC SAVX BPL PRTNU1 RTS;*********************************;  OUTPUT CHAR TO OPEN CHANNEL;*********************************PCHAR PHA ;SAVE CHAR LDA DEVICE ;GET FILE FLAG AND #$08 ;CHECK FOR DISK BEQ PRIN ;IF NONE BRANCH LDX #$08 ;DISK FILE #1 JSR CHKOUT ;FILE IS OUTPUT PLA ;GET CHAR PHA ;RESAVE CHAR JSR CHROUT ;OUTPUT TO DISK JSR CLRCHN ;RESET OUTPUTPRIN LDA DEVICE ;GET DEVICE FLAG AND #$04 ;CHECK FOR PRINTER BEQ SCREN ;IF NOT BRANCH LDX #$04 ;PRINT FILE #4 JSR CHKOUT ;FILE IS OUTPUT PLA ;GET CHAR PHA ;RESAVE CHAR JSR CHROUT ;OUTPUT TO PRINTER JSR CLRCHN ;RESET OUTPUTSCREN LDA DEVICE ;GET DEVICE FLAG AND #$03 ;CHECK FOR SCREEN BEQ PEXIT ;IF NOT BRANCH PLA ;GET CHAR PHA ;RESAVE CHAR JSR CHROUT ;OUTPUT TO SCREENPEXIT PLA ;GET CHAR RTS ;RETURN;*********************************; PRINTER OUTPUT ROUTINES;*********************************; FINISH OUT PAGE WITH CR;*********************************FINISH JSR CRLFPR ;PRINT CR INC LISTCT ;INC LINE COUNT LDA LISTCT ;GET COUNT CMP #$42 ;66 LINES BNE FINISH ;IF NOT MORE LDA #$00 ;ZERO BYTE STA LISTCT ;RESET COUNT RTS ;RETURN;*********************************; PRINT CR TO PRINTER;*********************************CRLFPR LDA #$04 ;DEVICE #4 STA DEVICE ;SET PRINTER JSR CRLF ;CR LDA OUTPUT ;GET DEVICE STA DEVICE ;RESET DEVICE RTS ;RETURN;*********************************; START NEWLINE AND CHECK COUNT;*********************************NEXPTR JSR CRLFPR ;PRINT CRNEXLIN INC LISTCT ;INC LINE COUNT LDA LISTCT ;GET COUNT CMP #$3C ;48 LINES BNE LINEOK ;IF NOT BRANCH JSR FINISH ;FINISH PAGE;*********************************; START NEW PAGE WITH HEADING;*********************************HEADER LDA DEVICE ;CHECK DEVICE AND #$04 ;PRINTER? BEQ LINEOK ;IF NOT EXIT JSR NEXPTR ;NEXT LINE LDA #$04 ;DEVICE #4 STA DEVICE ;SET DEVICE LDA #<XTITLE ;HEADER LDY #>XTITLE ; JSR STRPNT ;PRINT IT;*********************************; PRINT PAGE COUNT AND HEADER;********************************* LDX PAGECT LDA PAGECT+1 JSR PRTPAG JSR NEXPTR JSR NEXPTR LDA #$04 STA DEVICE LDA #<LTITLE LDY #>LTITLE JSR STRPNT JSR NEXPTR;*********************************; INC PAGE COUNT;********************************* INC PAGECT BNE PAGER1 INC PAGECT+1PAGER1 JSR NEXPTR JSR NEXPTRLINEOK RTS ;*********************************; SYMBOL TABLE ROUTINES;*********************************; START NEWLINE AND CHECK COUNT;*********************************NEXPTS JSR CRLFPR ;PRINT CR INC LISTCT ;INC LINE COUNT LDA LISTCT ;GET COUNT CMP #$3C ;48 LINES BNE HEADOK ;IF NOT BRANCH JSR FINISH ;FINISH PAGE;*********************************; START NEW PAGE WITH HEADING;*********************************HEADES JSR NEXPTS ;NEXT LINE LDA #<XTITLS ;HEADER LDY #>XTITLS ; JSR STRPNT ;PRINT IT JSR NEXPTS JSR NEXPTS LDA #<LTITLS LDY #>LTITLS JSR STRPNT JSR NEXPTSHEADOK RTS;*********************************; CHECK FOR NEW PAGE FOR SYMBOL;*********************************HEADSY LDA LISTCT CMP #$35 BCS HEADFX JSR NEXPTS JMP NEXPTSHEADFX JMP FINISH;*********************************; SCREEN UTILITES;*********************************SCROFF LDA DEVICE AND #$04 BEQ SCRNO1 LDA VICREG AND #$EF STA VICREGSCRNO1 RTS;*********************************SCRON LDA VICREG ORA #$10 STA VICREG RTS;*********************************; HEX-TO-ASCII TABLE;*********************************HEXA .TEXT '0123456789ABCDEF';*********************************; CONSTANTS FOR PRTNUM ROUTINE;*********************************CONST0 .BYTE $01,$0A,$64,$E8,$10CONST1 .BYTE $00,$00,$00,$03,$27;*********************************; PAGE TITLE;*********************************XTITLE .TEXT 'DISASSEMBLER64.......PAGE ' .BYTE $00LTITLE .TEXT 'LINE# LOC   CODE        LINE' .BYTE $00;********************************; SYMBOL PAGE TITLE;********************************XTITLS .TEXT 'SYMBOL TABLE',0LTITLS .TEXT 'SYMBOL VALUE',0;*********************************;.FIL 0:MODE.ASM;*********************************;.END;*********************************; FILE MODE.ASM;*********************************;;        DISASSEMBLER64;    SYMBOLIC DISASSEMBLER;       BY DENTON MARLOWE;;  (C)1986 BY DENTON MARLOWE;;*********************************; ADDRESSING MODE UTILITIES;*********************************;      DISASSEMBLE ONE LINE;*********************************DSLINE JSR DATAOP ;CHECK FOR DATA       BMI BYTT   ;N=1 THEN FOUND;*********************************; CHECK BIT ZP DECODING OPTIONS;*********************************       LDA BITFLG ;CHECK BIT FLAG       BEQ DISL   ;IF ZERO NO BIT       JSR GETSL  ;GET BYTE       CMP #$24   ;ZEROPAGE BIT       BEQ BYZBIT ;       CMP #$2C   ;ZEROPAGE BIT       BEQ BYABIT ;       BNE DISL   ;;*********************************; CHECK BIT ABS DECODING OPTIONS;*********************************;********************************; PROCESS LINE OF CODE;********************************DISL = *       JSR GETSL  ;GET BYTE       LDX PASS   ;GET PASS COUNT       CPX CPASS  ;LAST       BEQ DISL1  ;IF LAST BRANCH       JSR OPERN1 ;IF LAST BRANCH       JMP BYTT   ;NEXT INSTRUCTION;********************************; PRINT DISASSEMBLY ADDRESS;********************************DISL1  JSR PRTASS ;PRINT LINE DATA       JSR PRAD   ;PRINT ADDRESS       JSR SPACE  ;SPACE OVER;********************************; PRINT INSTRUCTION;********************************       JSR GETSL  ;GET BYTE       PHA        ;STORE       JSR MNEMON ;PRINT MNEMONIC       JSR SPACE  ;SPACE OVER       PLA        ;GET BYTE       JSR OPERND ;PRINT OPERANDFINAL  JSR NEWLIN ;START NEW LINEBYTT   JMP NEXTSL ;NEXT INSTRUCTION;********************************;      BIT ZP SKIP TRICK;; THE SKIP WILL ALWAYS INVOLVE; A FOLLWING OPCODE THAT IS EITHER; AN OPCODE WITH NO OPERAND OR; OR ONE BYTE OPERAND LIKE A BRANCH; OR ZERO PAGE INSTRUCTION;*********************************BYZBIT = *       LDA BITFLG       AND #$02       BEQ DISL;********************************;      TO SKIP OR NOT;*********************************      JSR INCSL  ;INC TO OPERAND      JSR GETSL  ;GET OPERAND      PHA      JSR DECSL      PLA                 ;CHECK FOR SKIP      CMP #$10   ;BPL SKIP      BEQ B0000      CMP #$18   ;CLC SKIP      BEQ B0000      CMP #$30   ;BMI      BEQ B0000      CMP #$38   ;SEC      BEQ B0000;      JMP DISL;********************************;      BIT ABS SKIP TRICK;*********************************BYABIT = *       LDA BITFLG       AND #$01       BEQ DISL;********************************;      TO SKIP OR NOT;*********************************      JSR INCSL  ;INC TO OPERAND      JSR GETSL  ;GET OPERAND      PHA      JSR DECSL      PLA                 ;CHECK FOR SKIP      CMP #$A1   ;LDY A IMMEDIATE SKIP      BEQ B0000      CMP #$A2   ;LDA A IMMEDIATE SKIP      BEQ B0000      CMP #$A9   ;LDX A IMMEDIATE SKIP      BEQ B0000      CMP #$65   ;ADC ZP      BEQ B0000      CMP #$85   ;STA ZP      BEQ B0000      CMP #$B1   ;LDA (ZP),Y      BEQ B0000      CMP #$E6   ;INC      BEQ B0000;      JMP DISL;********************************;      PRINTING PASS?;*********************************B0000 = *       LDA PASS  ;GET PASS COUNT       CMP CPASS ;LAST       BNE BYTT  ;IF NOT NEXT BYTE;*********************************;  PRINT LINE DATA FOR .BYTE;*********************************       JSR COMENT    ;COMENT LINE;       JSR PRTDAT    ;PRINT LINE DATA       JSR PRTONE    ;ONE BYTE       JSR PRAD      ;PRINT ADDRESS       JSR SPACE     ;SPACE OVER       LDA #<MSGBIT  ;.BYTE $       LDY #>MSGBIT  ;       JSR STRPNT    ;PRINT IT;       JSR GETSL     ;GET BYTE       JSR PRBYT     ;PRINT BYTE;       LDA #<MSGBZP  ;BIT COMMENT       LDY #>MSGBZP  ;       JSR STRPNT    ;PRINT IT;       JSR NEWLIN   ;PRINT BYTE       ;JSR INCSL    ;INC SELECT       JSR COMET    ;COMENT LINE       ;JSR DECSL    ;REASET SELECT       JMP FINAL    ;CR AND NEXT BYTE;*********************************;BYTEXT JMP DISL1;*********************************; ADDRESSING MODE UTILITIES;*********************************;;*********************************; ANALYSIS OPERAND ROUTINES;*********************************;    BIT ZP ONE-BYTE OPERAND; ZERO PAGE BIT IS ALMOST ALWAYS;   A BIT TRICK TO SKIP THE NEXT;          OPCODE;********************************ONEBIT NOP;*********************************;      ONE-BYTE OPERAND;********************************ONEBYT JSR INCSL ;INC TO BYTE JSR GETSL ;GET BYTE STA WORKED ;STORE OPERAND LDA #$00 ;ZERO BYTE STA WORKED+1 ;ZERO HIGH BYTE LDA PASS ;GET PASS COUNT CMP IPASS       ;INTERNAL BEQ OPCPUT ;TABLE OPERAND CMP EPASS       ;EXTERNAL BEQ OPCSYM ;EXTERNAL EQUATE;*********************************; OUTPUT OPERAND;********************************* JSR SYMOP ;CHECK FOR SYMBOL BCS TWOB ;SYMBOL FOUND JSR RANGE ;IS IT INTERNAL BCC ONEBY ;GENERATE LABEL JSR DOLLAR ;EXTERNAL JMP ONEBX ;PRINT ADDRESSONEBY JSR PRLA ;PRINT XXONEBX LDA WORKED ;GET OPERAND JMP PRBYT ;PRINT BYTE;********************************;      BIT ABS TWO-BYTE OPERAND;********************************TWOBIT NOP;********************************;      TWO-BYTE OPERAND;********************************TWOBYT JSR INCSL ;INC TO BYTE JSR GETSL ;GET BYTE STA WORKED ;STORE LOW BYTE JSR INCSL ;INC TO BYTE JSR GETSL ;GET BYTE STA WORKED+1 ;STORE HIGH BYTE LDA PASS ;GET PASS COUNT CMP IPASS       ;INTERNAL BEQ OPCPUT ;TABLE OPERNAD CMP EPASS       ;EXTERNAL BEQ OPCSYM ;EXTERNAL EQUATE;********************************;  OUTPUT OPERAND;******************************** JSR SYMOP  ;CHECK SYMBOL BCS TWOB   ;C=1 FOUND ONE JSR RANGE  ;IS IT INTERNAL BCC TWOBY  ;GERNERATE LABEL JSR DOLLAR ;EXTERNAL JMP TWOBX  ;;********************************;  OUTPUT OPERAND;********************************TWOBY =* JSR PRLA   ;PRINT XXTWOBX = * JMP PWORKD ;PRINT ADDRESSOPCPUT = * JMP PUTI   ;PUT IN TABLEOPCSYM = * JMP SYMOP  ;CHECK EXT EQUATETWOB = * RTS        ;RETURN;*********************************; ILLEGAL MODES, UNUSED OPCODES;; ZZZZ XX .BYTE $XX ;'Y' ;??? ILLEGAL OPCODE;;*********************************ILLEGL INC ERRCT   ;INC ERROR COUNT       BNE *+5     ;SKIP NEXT LINE       INC ERRCT+1 ;INC ERROR COUNT       LDY #>MBYTE ;.BYTE       LDA #<MBYTE ;       JSR STRPNT  ;PRINT STRING       JSR DOLLAR  ;PRINT $       JSR GETSL   ;GET ILLEGAL BYTE       ;BEGIN REV 2017-3       PHA         ;PUT BYTE ON STACK;       JSR PRBYT   ;PRINT IT       JSR SPACE   ;SPACE OVER;       PLA         ;POP BYTE OFF STACK       JSR CASCII  ;IS IT PRINTABLE ASCII       BCS ISKIP   ;IF NOT EXIT       PHA         ;STACK IT       JSR SPACE   ;SPACE OVER       JSR SEMIC   ;COMMENT       LDA #"'"    ;QUOTE       JSR PCHAR   ;PRINT IT       PLA         ;POP IT       JSR PCHAR   ;PRINT IT       LDA #"'"    ;QUOTE       JSR PCHAR   ;PRINT IT       JSR SPACE   ;SPACE OVER;ISKIP = *;END REV 2017-3       LDY #>ILLMSG       LDA #<ILLMSG       JMP STRPNT;********************************;      ACCUMULATOR MODE;********************************ACC LDA #'A'     ;ASCII A JMP PCHAR ;PRINT IT;********************************;       IMMEDIATE MODE;********************************IMMEDT JSR INCSL ;INC TO DATA BYTE LDX PASS ;GET PASS CPX CPASS ;LAST PASS BNE IMEXIT ;EXIT LDA #'#'        ;ASCII # JSR PCHAR ;PRINT IT JSR DOLLAR ;PRINT $ JSR GETSL ;GET BYTE PHA ;STACK IT JSR PRBYT ;PRINT IT PLA ;POP IT JSR CASCII ;PRINTABLE ASCII BCS IMEXIT ;IF NOT EXIT PHA ;STACK IT JSR SPAC6 ;SPACE OVER JSR SEMIC ;COMMENT LDA #"'"        ;QUOTE JSR PCHAR ;PRINT IT PLA ;POP IT JSR PCHAR ;PRINT IT LDA #"'"        ;QUOTE JSR PCHAR ;PRINT ITIMEXIT RTS ;EXIT;*********************************;      BIT ZERO PAGE MODE;*********************************ZERBIT NOP;*********************************;      ZERO PAGE MODE;*********************************ZEROPG JMP ONEBYT ;PRINT ONE BYTE;*********************************;      ZERO PAGE,X MODE;********************************ZEROX JSR ONEBYT ;PRINT ONE BYTE JMP XINDEX ;PRINT ,X;********************************;       ZERO PAGE,Y MODE;********************************ZEROY JSR ONEBYT ;PRINT ONE BYTE JMP YINDEX ;PRINT ,Y;*********************************;         BIT ABSOLUTE MODE;*********************************ABSBIT NOP;*********************************;         ABSOLUTE MODE;*********************************ABSLUT JSR TWOBYT ;PRINT TWO BYTE JSR DECSL ;DEC TO SECOND JSR DECSL ;DEC TO OPCODE JSR GETSL ;GET BYTE PHA JSR INCSL JSR INCSL PLA CMP #$4C ;IS IT JMP BNE ABSEXT ;IF NOT EXIT JSR NEWLIN ;NEXT LINE JSR INCSL JSR COMET ;COMMENT LINE JSR DECSLABSEXT RTS ;RETURN;*********************************;       ABSOLUTE,X MODE;********************************ABSX JSR TWOBYT ;PRINT TWO BYTE JMP XINDEX ;PRINT ,X;********************************;       ABSOLUTE,Y MODE;********************************ABSY JSR TWOBYT ;PRINT TWO BYTE JMP YINDEX ;PRINT ,Y;********************************;       IMPLIED MODE;********************************IMPLID JSR GETSL ;GET BYTE BEQ IMPLI1 ;BRK CMP #$60 ;CHECK CODE BEQ IMPLI1 ;RTS CMP #$40 ;CHECK CODE BEQ IMPLI1 ;RTIIMPONE RTS ;RETURNIMPLI1 JSR NEWLIN ;PRINT NEW LINE JSR INCSL JSR COMET ;COMMENT LINE JMP DECSL;********************************;       INDIRECT MODE;********************************INDRCT JSR LPAREN ;PRINT ( JSR TWOBYT ;PRINT TWO BYTE JSR RPAREN ;PRINT ) JSR NEWLIN ;NEXT LINE JSR INCSL JSR COMET ;COMMENT LINE JMP DECSL;********************************;     INDIRECT,X MODE;********************************INDX JSR LPAREN ;PRINT ( JSR ZEROX ;PRINT $HH,X JMP RPAREN ;PRINT );********************************;     INDIRECT,Y MODE;********************************INDY JSR LPAREN ;PRINT ( JSR ONEBYT ;PRINT ONE BYTE JSR RPAREN ;PRINT ) JMP YINDEX ;PRINT ,Y;*********************************;      RELATIVE MODE;*********************************RELATV JSR INCSL    ;INC BYTE POINTER       LDA PASS     ;GET PASS COUNT       CMP EPASS    ;EXTERNAL       BEQ RELSYM   ;EXIT ON EXTERNAL;       LDA SELECT   ;GET LOW POINTER       STA WORKED   ;STORE TEMP       LDA SELECT+1 ;GET HIGH POINTER       STA WORKED+1 ;STORE TEMP       INC WORKED   ;ADD 1 TO ADDRESS       BNE *+5      ;ZERO MEANS CARRY       INC WORKED+1 ;INC HIGH ADDRESS;       JSR GETSL    ;GET BYTE BRANCH OFFSET       CMP #$00     ;IS IT ZERO       BPL FORWRD   ;IF SO BRANCH       DEC WORKED+1 ;DEC HIGH POINTERFORWRD CLC          ;CLEAR CARRY FLAG       ADC WORKED   ;ADD IN OPERAND       BCC RELND    ;TO SELECT ADDRES       INC WORKED+1 ;AND NOW POINTSRELND  STA WORKED   ;TARGET ADDRESS;       LDA PASS     ;GET PASS COUNT       CMP IPASS    ;INTERNAL       BEQ RELPUT   ;ADDRESS TABLE;       JSR SYMOP    ;CHECK FOR SYMBOL       BCS RELSYM   ;C=1 SYMBOL;       LDA ROPT     ;CHECK OPTION       CMP #$01     ;REL TO * ?       BEQ RELPC    ;IF SO DO IT;       JMP PWORK    ;PRINT ADDRESS;RELPUT = *       JMP PUTI     ;PUT IN TABLE;RELSYM RTS          ;RETURN;*********************************; PRINT RELATIVE TO PC;*********************************RELPC JSR GETSL ;GET BRANCH DATA PHA ;SAVE ON STACK BMI RELNEG ;BACKWARD ? LDA #<POSREL LDY #>POSREL JMP RELPMRELNEG LDA #<NEGREL LDY #>NEGRELRELPM JSR STRPNT PLA ;GET BRANCH DATA CLC ;CLEAR CARRY ADC #$02 ;ADD 2 FOR BRANCH BPL RELP ;FORWARD ? CLC ;CLEAR CARRY EOR #$FF ;COMPLMENT ADC #$01 ;ADD 1 FOR 2'SRELP JSR PRBYT ;PRINT BRANCH JSR SPAC6 ;SPACE JSR SEMIC ;COMMENT CHAR JMP PWORK ;PRINT ADDRESS;*********************************;  ORGIN LABEL;*********************************ORGIN JSR PRTOTH ;PRINT LINE DATA LDA #'*'        ;PC JSR PCHAR ;PRINT IT LDA #'='        ;EQUALS JSR PCHAR ;PRINT IT JSR DOLLAR ;ASCII $ JSR PSELEC ;PRINT ADDRESS JMP NEWLIN ;START NEWLINE;*********************************; END OF FILE LABLE;*********************************EFILE JSR COMENT ;COMMENT LINE JSR PRTOTH ;PRINT LINE DATA LDA #<MSGEND ;END MESSAGE LDY #>MSGEND JSR STRPNT ;PRINT IT JMP NEWLIN ;NEW LINE;*********************************; PRINT COMMENT LINE;*********************************COMENT JSR COMET ;PRINT COMMENT JMP NEWLIN ;NEXT LINE;*********************************COMET JSR PRTOTH ;PRINT LINE DATA JSR SEMIC ;PRINT COMMENT LDA FOROPT BNE CSHORT LDY #$20 ;COUNTER .BYTE $2CCSHORT LDY #$10COMPT LDA #'*'    ;STAR JSR PCHAR ;PRINT CHAR DEY ;DEC COUNTER BNE COMPT ;20 OR 10 STARS RTS ;RETURN;*********************************;     PRINT SELECTED ADDRESS;*********************************PRLA LDA #'X' ;XX LABEL JSR PCHAR ; LDA #'X'     ; JMP PCHAR ;;*********************************; PRINT CODE ADDRESS;*********************************PRAD JSR SYM ;CHECK FOR SYMBOLIC BCS NPRAD1 ;C=1 SYMBOLIC LABEL LDA XOPT ;CHECK GENERATION BEQ P1 ;NO LABELS JSR INTCHA ;IS ADDRESS IN TAB BCS P1 ;C=1 YES LDA FOROPT ;CHECK FORMAT BEQ POVER  ;STD FORMAT JMP SPACE  ;ONE SPACEPOVER JMP SPAC6 ;SPACE OVER;*********************************; PRINT ADDRESS AS LABEL;*********************************P1 JSR PRLA ;PRINT XX JSR PSELEC ;PRINT ADDRESS NOP NOP NOPNPRAD RTS ;RETURN;*********************************NPRAD1 LDA FOROPT BNE NPRAD JMP FIXSYM;*********************************; PRINT SELECT ADDRESS;*********************************PSELEC LDA SELECT ;LOW BYTE LDY SELECT+1 ;HIGH BYTE JMP PRBYTS ;PRINT THEM;*********************************; PRINT WORKED ADDRESS WITH XX;*********************************PWORK JSR PRLA ;PRINT XX;*********************************; PRINT WORKED ADDRESS;*********************************PWORKD LDA WORKED ;LOW BYTE LDY WORKED+1 ;HIGH BYTE JMP PRBYTS ;PRINT THEM;********************************; PRINT SEMICOLON FOR COMMENT;********************************SEMIC LDA #';' JMP PCHAR;********************************; PRINT DOLLAR SIGN FOR HEX;********************************DOLLAR LDA #'$' JMP PCHAR;********************************; PRINT LEFT PARENTTHESES;********************************LPAREN LDA #'(' JMP PCHAR;********************************; PRINT RIGHT PARENTTHESES;********************************RPAREN LDA #')' JMP PCHAR;********************************; PRINT A COMMA AND AN "X";********************************XINDEX LDA #',' JSR PCHAR LDA #'X' JMP PCHAR;********************************; PRINT A COMMA AND A "Y";********************************YINDEX LDA #',' JSR PCHAR LDA #'Y' JMP PCHAR;********************************; PRINT CARRAIGE RETURN;*********************************CRLF LDA #$0D ;ASCII CR JMP PCHAR ;PRINT;*********************************; PRINT SIX SPACES;*********************************SPAC6 LDA #$05SPACM STA TEMPSPAC JSR SPACE DEC TEMP BNE SPAC;*********************************; PRINT SPACE;*********************************SPACE LDA #$20 ;ASCII SPACE JMP PCHAR ;PRINT;*********************************; SELECT NEXT BYTE;*********************************NEXTSL LDA SELECT+1 CMP EA+1 BCC SLOK BNE NOINC LDA SELECT CMP EA BCS NOINCSLOK JSR INCSL CLC RTSNOINC SEC RTS;*********************************; INC SELECTED BYTE;*********************************INCSL INC SELECT BNE *+5 INC SELECT+1 RTS;*********************************; GET SELECTED BYTE;*********************************GETSL CLC LDA SELECT ADC OFFSET STA ZEROUR LDA SELECT+1 ADC OFFSET+1 STA ZEROUR+1 LDY #$00 LDA (ZEROUR),Y RTS;*********************************; DEC SLECTED BYTE;*********************************DECSL LDA SELECT BNE *+5 DEC SELECT+1 DEC SELECT RTS;*********************************; INITIALIZE SELECT;*********************************INTSA LDA SA STA SELECT LDA SA+1 STA SELECT+1 RTS;*********************************; ASCII STRING DATA;*********************************MSGBIT .TEXT '.BYTE $',0MSGBZP .TEXT ' ;BIT ZP SKIP',0POSREL .TEXT '*+$',0NEGREL .TEXT '*-$',0MSGEND .TEXT '.END',0ILLMSG .TEXT ';??? ILLEGAL OPCODE',0;*********************************; PRINT ONE BYTE OPCODE DATA;*********************************PRTONE JSR GETSL ;GET BYTE JSR PRBYT ;PRINT BYTE LDA FOROPT BEQ PRTON1 LDA #$07 .BYTE $2CPRTON1 LDA #$09 ;10 SPACES JSR SPACM ; JMP PRTEST ;RESET I/O DEVICE;*********************************; PRINT TWO BYTE OPCODE DATA;*********************************PRTTWO JSR GETSL ;GET BYTE JSR PRBYT ;PRINT BYTE JSR SPACE ; JSR INCSL ;INC TO OPERAND JSR GETSL ;GET BYTE JSR PRBYT ;PRINT IT LDA FOROPT BEQ PRTTW1 LDA #$04 .BYTE $2CPRTTW1 LDA #$06 ;7 SPACES JSR SPACM ; JSR DECSL ;RESET POINTER JMP PRTEST ;RESET I/O DEVICE;*********************************; PRINT THREE BYTE OPCODE DATA;*********************************PRTTHE JSR GETSL ;GET BYTE JSR PRBYT ;PRINT BYTE JSR SPACE ; JSR INCSL ;INC TO OPERAND JSR GETSL ;GET BYTE JSR PRBYT ;PRINT IT JSR SPACE ; JSR INCSL ;INC TO LAST BYTE JSR GETSL ;GET BYTE JSR PRBYT ;PRINT IT LDA FOROPT BEQ PRTTH1 LDA #$01 .BYTE $2CPRTTH1 LDA #$03 ;4 SPACES JSR SPACM ; JSR DECSL ;DEC POINTER JSR DECSL ;DEC POINTER;*********************************; RESET I/O DEVICE (DISK IF USED);*********************************PRTEST LDA OUTPUT ;GET I/O DEVICE STA DEVICE ;RESET I/O RTS ;RETURN;*********************************; PRINT LINE DATA FOR OPCODE;*********************************PRTDAT LDA DEVICE ;OUTPUT DEVICE AND #$07 ;MASK DISK STA DEVICE ;RESET LDA FOROPT ;CHECK FORMAT BNE PRTDAF ;SKIP LINE # LDA LINECT+1 ;HIH BYTE LINE LDX LINECT ;LOW BYTE LINE JSR PRTNUM ;PRINT NUMBER JSR SPACE ; JSR SPACE ;PRTDAF JSR PSELEC ;PRINT ADDRESS LDA #$01 ;2 SPACES JMP SPACM ;;*********************************; PRINT LINE DATA FOR OTHER LINES;*********************************PRTOTH JSR PRTDAT ;PRINT LINE LDA FOROPT BEQ PRTOT1 LDA #$09 .BYTE $2CPRTOT1 LDA #$0B ;12 SPACES JSR SPACM ; JMP PRTEST ;RESET I/O;********************************;.FIL 0:INTERNAL.ASM;********************************;.END;*********************************; FILE INTERNAL.ASM;*********************************;;        DISASSEMBLER64;    SYMBOLIC DISASSEMBLER;       BY DENTON MARLOWE;;  (C)1986 BY DENTON MARLOWE;;*********************************; INTERNAL ADDRESS TABLE ROUTINES;*********************************; CHECK FOR OUT OF RANGE ADDRESS;*********************************RANGE LDA WORKED+1 ;GET HIGH CMP EAGOL+1 ;COMPARE BCC RANG ;< CHECK START BNE ROUT ;> OUT OF RANGE LDA WORKED ;GET LOW CMP EAGOL ;COMPARE BCS ROUT ;> OUT OF RANGE;*********************************RANG LDA WORKED+1 ;GET HIGH CMP SAGOL+1 ;COMPARE BCC ROUT ;< OUT OF RANGE LDA WORKED ;GET LOW CMP SAGOL ;COMPARE BCC ROUT ;< OUT OF RANGE;********************************* CLC ;C=0 IN RANGE RTSROUT SEC ;C=1 OUT RANGE RTS;*********************************; INITIALIZE INTERNAL TABLE;*********************************INITIN LDA DATABE STA TABINS STA TABINE LDA DATABE+1 STA TABINS+1 STA TABINE+1;*********************************; INITIALIZE INTERNAL TABLE POINT;*********************************INTSET LDA TABINS STA TABINP LDA TABINS+1 STA TABINP+1 RTS;*********************************; SAVE INTERNAL TABLE POINTERS;*********************************SAVINT LDA TABINS STA SAVES LDA TABINS+1 STA SAVES+1 LDA TABINE STA SAVEE LDA TABINE+1 STA SAVEE+1 RTS;*********************************; RESTORE INTERNAL TABLE POINTERS;*********************************RESINT LDA SAVES STA TABINS LDA SAVES+1 STA TABINS+1 LDA SAVEE STA TABINE LDA SAVEE+1 STA TABINE+1 RTS;*********************************; PUT ADDRESS IN INTERNAL TABLE;*********************************PUTI SEC     LDA TABINS     SBC TABINE     STA TEMP     LDA TABINS+1     SBC TABINE+1     ORA TEMP     BEQ PUIT;     JSR INTCHK     ;IS ADDRESS IN TAB     BCS INTEXT     ;IF SO EXIT;PUIT LDA TABINE     ;GET LOW END     STA ZEROUR     ;STORE     LDA TABINE+1   ;GET HIGH END     STA ZEROUR+1   ;STORE     LDY #$00       ;OFFSET     LDA WORKED     ;GET LOW ADDRESS     STA (ZEROUR),Y ;PUT IN TABLE     INY            ;OFFSET TO HIGH     LDA WORKED+1   ;GET HIGH ADDRESS     STA (ZEROUR),Y ;PUT IN TABLE;     JSR SEMIC      ;PRINT ;     JSR PWORKD     ;PRINT ADDRESS;*********************************     JSR INCIE      ;INC TO HIGH & LOW     JMP INCIE      ;INC TO HIGH & LOW;INTEXT = *     CLC            ;C=0 FOR NO MATCH     RTS            ;RETURN;*********************************; INC INTERNAL END TABLE POINTER;*********************************INCIE INC TABINE BNE *+5 INC TABINE+1;*********************************; INC INTERNAL ADDRESS POINTER;*********************************INCI INC TABINP BNE *+5 INC TABINP+1 RTS;*********************************; GET BYTE FROM INTERNAL TABLE;*********************************GETI LDA TABINP STA ZEROUR LDA TABINP+1 STA ZEROUR+1 LDY #$00 LDA (ZEROUR),Y RTS;*********************************; CHECK IF ADDRESS IN TABLE;*********************************INTCHA LDA SELECT STA WORKED LDA SELECT+1 STA WORKED+1;*********************************INTCHK JSR INTSETINTCH  JSR GETI STA WORKER JSR INCI JSR GETI STA WORKER+1 SEC LDA WORKED+1 SBC WORKER+1 STA TEMP LDA WORKED SBC WORKER ORA TEMP BEQ INTMAT;********************************* JSR INCI LDA TABINP+1 CMP TABINE+1 BCC INTCH BNE INTEND LDA TABINP CMP TABINE BCC INTCH;*********************************INTEND CLC RTSINTMAT SEC RTS;*********************************; 2 BYTE TABLE SORT ROUTINE;*********************************SORT JSR INTSET ;SET POINTERS LDA TABINS STA SMALLS STA SMALLP LDA TABINS+1 STA SMALLS+1 STA SMALLP+1;*********************************; PUT FIRST WORD INTO TEMP;*********************************SORT1 JSR GETI STA TEMP JSR INCI JSR GETI STA TEMP+1;*********************************; INC TO NEXT WORD AND COMPARE; SMALLP POINTS TO LOW BYTE;*********************************SORT2 JSR INCI LDA TABINP STA SMALLP LDA TABINP+1 STA SMALLP+1 JSR GETI STA WORKED JSR INCI LDA TABINP+1 CMP TABINE+1 BCC T2 BNE S3 LDA TABINP CMP TABINE BCC T2S3 JMP SORT3T2 JSR GETI STA WORKED+1 CMP TEMP+1 BCC SMALL BNE LARGE LDA WORKED CMP TEMP BCC SMALLLARGE JMP SORT2;*********************************; WORD IS SMALL THAN TEMP PUT IT; WHERE TEMP CAME FROM (SMALLS);*********************************SMALL LDA SMALLS STA ZEROUR LDA SMALLS+1 STA ZEROUR+1 LDY #$00 LDA WORKED STA (ZEROUR),Y INY LDA WORKED+1 STA (ZEROUR),Y;*********************************; PUT TEMP IN PLACE OF WORD; SMALLP POINTS TO LO ADDRESS;********************************* LDA SMALLP STA ZEROUR LDA SMALLP+1 STA ZEROUR+1 LDY #$00 LDA TEMP STA (ZEROUR),Y INY LDA TEMP+1 STA (ZEROUR),Y;********************************* LDA SMALLS STA TABINP LDA SMALLS+1 STA TABINP+1 JMP SORT1;*********************************; IF AFTER SCAN TO TABLE GOTO NEXT; WORD IN TABLE FOR CHECK;*********************************SORT3 CLC LDA SMALLS ADC #$02 STA SMALLS STA TABINP LDA SMALLS+1 ADC #$00 STA SMALLS+1 STA TABINP+1 LDA SMALLS+1 CMP TABINE+1 BCC SORTOK BNE SORT4 LDA SMALLS CMP TABINE BCS SORT4SORTOK JMP SORT1;*********************************SORT4 JMP INTSET;*********************************; PRINT INTERNAL ADDRESS TABLE;*********************************INTPRT SEC LDA TABINS SBC TABINE STA TEMP LDA TABINS+1 SBC TABINE+1 ORA TEMP BNE INTOUT RTS;*********************************INTOUT JSR HEADSY JSR SORT;*********************************LOOP1 LDA #$03 STA SAVAINTPR JSR GETI STA WORKED JSR INCI JSR GETI STA WORKED+1 JSR SPACE JSR SYMOP BCC INTPRS JSR FIXSYM LDA #$02 JSR SPACM JMP INTPRMINTPRS LDA #$08 JSR SPACMINTPRM JSR PWORKD JSR INCI LDA TABINP+1 CMP TABINE+1 BCC PRTOK BNE PREND LDA TABINP CMP TABINE BCS PRENDPRTOK DEC SAVA BMI LOOP2 LDA #$02 JSR SPACM JMP INTPRPREND JMP NEXPTSLOOP2 JSR NEXPTS JMP LOOP1;*********************************;.FIL 0:ASC.ASM;*********************************;.END;*********************************; FILE ASC.ASM;*********************************;;        DISASSEMBLER64;    SYMBOLIC DISASSEMBLER;       BY DENTON MARLOWE;;  (C)1986 BY DENTON MARLOWE;;*********************************; DATA TABLE HANDLER;*********************************DATAOP LDA NDATA ;GET NUM TABLES BEQ ENDAX ;IF ZERO EXIT LDA #$00 ;ZERO BYTE STA CDATA ;SET FIRST TABLE BEQ DATAO1 ;ENDAX JMP ENDDAT ;;*********************************DATAO1 LDA CDATA ;CURRENT TABLE CMP NDATA ;LAST TABLE DONE BEQ ENDAX ;IF SO EXIT ASL A ;CDATA*2 ASL A ;CDATA*4 CLC ADC CDATA ;CDATA*5 TAY ;PUT INTO INDEX LDA TDATA,Y ;START LOW STA WORKER ;STORE INY ;INC OFFSET LDA TDATA,Y ;START HIGH STA WORKER+1 ;STORE SEC ;C=1 LDA WORKER ; SBC SELECT ; STA TEMP ; LDA WORKER+1 ; SBC SELECT+1 ; ORA TEMP ; BEQ DATAO2 ;MATCH INC CDATA ;NEXT TABLE BNE DATAO1 ;CHECK FOR MATCH;*********************************; GET TABLE DATA;*********************************DATAO2 INY ;INC OFFSET LDA TDATA,Y ;END LOW STA EAS ;STORE INY ;INC OFFSET LDA TDATA,Y ;END HIGH STA EAS+1 ;STORE INY ;INC OFFSET LDA TDATA,Y ;DATA TYPE STA TEXTER ;STORE CMP #'S'       ;IS IT SKIPPER BNE ASCCCC ;;*********************************; SKIP RANGE OF ADDRESSES;********************************* LDA PASS CMP CPASS BNE ASCCCC LDA EAS STA SELECT LDA EAS+1 STA SELECT+1 JSR INCSL JSR ORGIN JSR DECSL JSR COMENT JMP DATUT;*********************************; CHECK PASS;*********************************ASCCCC LDA PASS CMP EPASS ;EXTERNAL BNE ASCKKSKIPER LDA EAS STA SELECT LDA EAS+1 STA SELECT+1 JMP DATUT;*********************************; DISASSEMBLER LOOP FOR DATA;*********************************ASCKK LDA PASS ;GET PASS CMP CPASS ;IS IT LAST BNE ASCI1 ;NO PRINT JSR COMENT ;COMMENT LINEASCII LDA PASS ;GET PASS CMP CPASS ;IS IT LAST BNE ASCI1 ;NO PRINT JSR PRTDAT ;PRINT LINEASCI1 JSR ACHECK ;DIS ONE LINE BCS ASCIIQ ;IF EA STOP;********************************* JSR STOP BEQ ASCIIQ JSR GETIN BEQ ASCII CMP #' ' BNE ASCII LDA DEVICE PHA LDA #$03 STA DEVICE LDA #<PMSG LDY #>PMSG JSR STRPNT PLA STA DEVICEPAUS1 JSR GETIN BEQ PAUS1 BNE ASCII;*********************************ASCIIQ LDA PASS ;GET PASS CMP CPASS ;IS IT LAST BNE DATUT ;EXIT JSR INCSL JSR COMENT ;COMMENT LINE JSR DECSL;*********************************; EXIT TO NEXTSL;*********************************DATUT LDA #$FF ;SET N=1 RTS ;RETURNENDDAT LDA #$00 ;SET N=0 RTS ;RETURN;*********************************; CHECK OPTIONS;*********************************ACHECK LDA TEXTER ;GET DATA TYPE CMP #'4'         ;WORD-1 BEQ AC0 CMP #'3'         ;DBYTE BEQ AC1 CMP #'2'         ;WORD BEQ AC0 JMP BYTES ;BYTE OR ASCIIAC0 JMP WORDS ;WORD OR WORD-1AC1 JMP DBYTES ;DBYTES;*********************************; .BYTE DIRECTIVE;*********************************BYTES LDA PASS ;GET PASS CMP CPASS ;IS IT LAST BNE BYTESX ;IF NOT EXIT JSR PRTONE ;PRINT BYTE JSR PRAD ;PRINT ADDRESS LDY #>MBYTE ;.BYTE LDA #<MBYTE ; JSR STRPNT ;PRINT IT LDA TEXTER ;GET TYPE CMP #'0'          ;ASCII BEQ ALINE ;ASCII BYTES JSR DOLLAR ;PRINT $ JSR GETSL ;GET BYTE JSR PRBYT ;PRINT BYTE JSR NEWLIN ;NEXT LINEBYTESX JMP NEXTBY ;NEXT BYTE;*********************************; ASCII TEXT;*********************************ALINE LDA #$00 ;ZERO BYTE STA TEMP ;STORE IN COUNT;*********************************; CHECK FIRST BYTE OF LINE;********************************* JSR GETSL ;GET BYTE JSR CASCII ;CHECK FOR ASCII BCS NASCII ;IF NOT BRANCH LDA #"'"      ;PRINT ONE QUOTE JSR PCHAR ;PRINT IT;*********************************ALOP JSR GETSL ;GET BYTE JSR CASCII ;IS IT ASCII BCS EASCII ;IF NOT END LINE JSR PCHAR ;PRINT ASCII; REV 2-12-2018 START; IF CHAR = ' THEN PRINT SECOND ' JSR GETSL ; GET BYTE AGAIN CMP #$27 ;''' BNE Q00000 JSR PCHAR ;PRINT ASCIIQ00000 = *; REV 2-12-2018 END  JSR NEXTBY ;INC SELECT BCS EASCI1 ;C=1 IF END INC TEMP ;INC COUNT LDA TEMP ;LOAD COUNT CMP #$28 ;40 CHAR BEQ EASCII ;IF SO END JMP ALOP ;NEXT;*********************************EASCI1 JSR EASCII SEC RTS;*********************************EASCII LDA #"'" ;PRINT ONE QUOTE JSR PCHAR ; JMP NEWLIN ;PRINT CR;*********************************NASCII JSR DOLLAR ;PRINT $ JSR GETSL ;GET BYTE JSR PRBYT ;PRINT IT JSR NEWLIN ;PRINT CR JMP NEXTBY ;NEXT SL;*********************************; CHECK ACCUM FOR PRINTABLE ASCII;*********************************CASCII CMP #$20 ;< SPACE BMI NOASC ;IF LESS NOASCII CMP #$60 ;> _ BCS NOASC ;IF GREATER NO CLC ;CLEAR CARRY OK RTS ;RETURNNOASC SEC ;SET CARRY BAD RTS ;RETURN;*********************************; .DBYTE DIRECTIVE;*********************************DBYTES LDA PASS ;CHECK PASS CMP CPASS ;LAST PASS BNE DBYTEX ;EXIT JSR PRTTWO ;PRINT 2 BYTES JSR PRAD ;PRINT ADDRESS LDY #>MDBYTE ;.DBYTE LDA #<MDBYTE ; JSR STRPNT ;PRINT IT JSR GETSL ;GET BYTE STA WORKED+1 ;STORE JSR INCSL ;GET BYTE JSR GETSL ;GET BYTE STA WORKED ;STORE JSR DOLLAR ;PRINT $ JSR PWORKD ;PRINT WORD JSR NEWLIN ;PRINT CRDBYTEX JMP NEXTBY ;NEXT SL;*********************************; .WORD DIRECTIVE;*********************************WORDS LDA PASS ;GET PASS CMP CPASS         ;LAST BNE WORD1 ;IF NOT BRANCH JSR PRTTWO ;PRINT 2 BYTES JSR PRAD ;PRINT ADDRESS LDY #>MWORD ;.WORD LDA #<MWORD ; JSR STRPNT ;PRINT IT;*********************************; GET WORD INTO WORKED;*********************************WORD1 JSR GETSL ;GET BYTE STA WORKED ;STORE BYTE STA SMALLP ;STORE BYTE JSR INCSL ;GET BYTE JSR GETSL ;GET BYTE STA WORKED+1 ;STORE BYTE STA SMALLP+1 ;STORE BYTE LDA TEXTER ;GET OPTION CMP #'4'          ;.WORD ADRS-1 BEQ WORDM ;BRANCH;*********************************; CHECK PASS;********************************* LDA PASS ;CHECK PASS CMP IPASS  ;INTERNAL BEQ WORDPT ;TABLE WORD CMP EPASS BEQ WORDSY;*********************************; PRINT WORD;********************************* JSR SYMOP ;CHECK SYMBOL BCS WORDS3 ;C=1 SYMBOL JSR DOLLAR ;PRINT $ JSR PWORKD ;PRINT WORD JSR NEWLIN ;PRINT CRWORDSX JMP NEXTBY ;NEXT SLWORDPT JSR PUTI ;PUT IN TABLE JMP NEXTBY ;NEXT SLWORDSY JSR SYMOP JMP NEXTBY;*********************************; .WORD ADDRESS-1;*********************************WORDM CLC LDA WORKED ADC #$01 STA WORKED LDA WORKED+1 ADC #$00 STA WORKED+1;*********************************; CHECK PASS;********************************* LDA PASS ;CHECK PASS CMP IPASS ;INTERNAL BEQ WORDPT ;TABLE WORD CMP EPASS ;EXTERNAL BEQ WORDSY ;TABLE WORD;*********************************; PRINT WORD;********************************* JSR SYMOP ;CHECK SYMBOL BCC WORDS2 ;C=0 NO SYMBOL LDA #'-' JSR PCHAR LDA #'1' JSR PCHAR JMP WORDS3;*********************************WORDS2 JSR DOLLAR ;PRINT $ LDA SMALLP STA WORKED LDA SMALLP+1 STA WORKED+1 JSR PWORKD ;PRINT WORDWORDS3 JSR NEWLIN ;PRINT CRWORDXX JMP NEXTBY ;NEXT SL;*********************************; SELECT NEXT BYTE OF DATA;*********************************NEXTBY LDA SELECT+1 CMP EAS+1 BCC SBLOK BNE NOBINC LDA SELECT CMP EAS BCS NOBINCSBLOK JSR INCSL CLC RTSNOBINC SEC RTS;*********************************MBYTE .TEXT ' .BYTE ',0MWORD .TEXT ' .WORD ',0MDBYTE .TEXT ' .DBYTE ',0;*********************************;.FIL 0:TABLE.ASM;*********************************;.END;*********************************; FILE TABLE.ASM;*********************************;;        DISASSEMBLER64;    SYMBOLIC DISASSEMBLER;       BY DENTON MARLOWE;;  (C)1986 BY DENTON MARLOWE;;*********************************;       PRINT MNEMONIC;; OPCODE IN A;; BUG ILLEGAL OPCODE WOULD PRINT OUT AS;; ZZZZ XX                 ...  .BYTE $XX ;??? ILLEGAL OPCODE; WHERE THE "..." WERE THREE NULLS; BECAUSE ILLEGAL OPCODE MNEMONIC IS CODES AS 0,0,0;;*********************************MNEMON LDX #3       ;3 CHARACTERS       STX TEMP     ;COUNTER       TAX          ;CODE IS INDEX       LDA MCODES,X ;GET OFFSET       TAX          ;INDEX OFFSETMNLOOP LDA MNAMES,X ;GET CHARACTER;BEGIN REV 2017-0       BEQ ILLOP    ;ILLEGAL OPCODE MNEMONIC CHAR IS A NULL;END REV 2017-0       STX SAVX     ;SAVE INDEX       JSR PCHAR    ;PRINT CHAR       LDX SAVX     ;GET INDEX;BEGIN REV 2017-1ILLOP = *;END REV 2017-0       INX          ;NEXT CHAR       DEC TEMP     ;DEC COUNT       BNE MNLOOP   ;LOOP TILL 0       RTS          ;RETURN;*********************************;        PRINT OPERAND;*********************************PRTASS PHA ;STACK INDEX JSR PRTDAT ;PRINT LINE DATA PLA ;PULL INDEX TAY ;SAVE INDEX LDA #<SUBP LDX #>SUBP JMP GETOPE ;LOOK UP ROUTINE;*********************************OPERN1 TAY ;SAVE INDEX LDA #<SUBS1 LDX #>SUBS1 JMP GETOPE ;LOOK UP ROUTINE;*********************************OPERND TAY ;SAVE INDEX LDA #<SUBS LDX #>SUBS;*********************************; LOOK UP AND JMP TO ROUTINE;*********************************GETOPE STA ZEROUR ;LOW TABLE STX ZEROUR+1 ;HIGH TABLE LDA MODES,Y ;GET OFFSET TAY ;INDEX OFFSET LDA (ZEROUR),Y ;GET LOW BYTE STA ADRS ;STORE INY ;INC INDEX LDA (ZEROUR),Y ;GET HIGH BYTE STA ADRS+1 ;STORE JMP (ADRS) ;INDIRECT JMP;*********************************; TABLE OF ADDRESSING MODE SUBS;*********************************; MACHINE LANGUAGE ROUTINES;*********************************SUBP = *     ; MODES.WORD PRTONE ; 0  $00.WORD PRTONE ; 2  $02.WORD PRTTWO ; 4  $04.WORD PRTTWO ; 6  $06.WORD PRTTWO ; 8  $08.WORD PRTTWO ; 10 $0A.WORD PRTTHE ; 12 $0C.WORD PRTTHE ; 14 $0E.WORD PRTTHE ; 16 $10.WORD PRTONE ; 18 $12.WORD PRTTWO ; 20 $14.WORD PRTTWO ; 22 $16.WORD PRTTWO ; 24 $18.WORD PRTTHE ; 26 $1A;*********************************; CODE ANALYSIS ROUTINES;*********************************SUBS1 = *    ; MODES.WORD IMPONE ; 0  $00.WORD IMPONE ; 2  $02.WORD IMMEDT ; 4  $04.WORD ONEBYT ; 6  $06.WORD ONEBYT ; 8  $08.WORD ONEBYT ; 10 $0A.WORD TWOBYT ; 12 $0C.WORD TWOBYT ; 14 $0E.WORD TWOBYT ; 16 $10.WORD IMPONE ; 18 $12.WORD RELATV ; 20 $14.WORD ONEBYT ; 22 $16.WORD ONEBYT ; 24 $18.WORD TWOBYT ; 26 $1A;*********************************; FINAL PASS ADDRESSING MODES;*********************************SUBS  = *    ; MODES.WORD ILLEGL ; 0  $00.WORD ACC    ; 2  $02.WORD IMMEDT ; 4  $04.WORD ZEROPG ; 6  $06.WORD ZEROX  ; 8  $08.WORD ZEROY  ; 10 $0A.WORD ABSLUT ; 12 $0C.WORD ABSX   ; 14 $0E.WORD ABSY   ; 16 $10.WORD IMPLID ; 18 $12.WORD RELATV ; 20 $14.WORD INDX   ; 22 $16.WORD INDY   ; 24 $18.WORD INDRCT ; 26 $1A;*********************************; LIST OF MNEMONICS;*********************************MNAMES = *  ; MCODES.BYTE 0,0,0 ; 0   $00.TEXT 'ADC' ; 3   $03.TEXT 'AND' ; 6   $06.TEXT 'ASL' ; 9   $09.TEXT 'BCC' ; 12  $0C.TEXT 'BCS' ; 15  $0F.TEXT 'BEQ' ; 18  $12.TEXT 'BIT' ; 21  $15.TEXT 'BMI' ; 24  $18.TEXT 'BNE' ; 27  $1B.TEXT 'BPL' ; 30  $1E.TEXT 'BRK' ; 33  $21.TEXT 'BVC' ; 36  $24.TEXT 'BVS' ; 39  $27.TEXT 'CLC' ; 42  $2A.TEXT 'CLD' ; 45  $2D.TEXT 'CLI' ; 48  $30.TEXT 'CLV' ; 51  $33.TEXT 'CMP' ; 54  $36.TEXT 'CPX' ; 57  $39.TEXT 'CPY' ; 60  $3C.TEXT 'DEC' ; 63  $3F.TEXT 'DEX' ; 66  $42.TEXT 'DEY' ; 69  $45.TEXT 'EOR' ; 72  $48.TEXT 'INC' ; 75  $4B.TEXT 'INX' ; 78  $4E.TEXT 'INY' ; 81  $51.TEXT 'JMP' ; 84  $54.TEXT 'JSR' ; 87  $57.TEXT 'LDA' ; 90  $5A.TEXT 'LDX' ; 93  $5D.TEXT 'LDY' ; 96  $60.TEXT 'LSR' ; 99  $63.TEXT 'NOP' ; 102 $66.TEXT 'ORA' ; 105 $69.TEXT 'PHA' ; 108 $6C.TEXT 'PHP' ; 111 $6F.TEXT 'PLA' ; 114 $72.TEXT 'PLP' ; 117 $75.TEXT 'ROL' ; 120 $78.TEXT 'ROR' ; 123 $7B.TEXT 'RTI' ; 126 $7E.TEXT 'RTS' ; 129 $81.TEXT 'SBC' ; 132 $84.TEXT 'SEC' ; 135 $87.TEXT 'SED' ; 138 $8A.TEXT 'SEI' ; 141 $8D.TEXT 'STA' ; 144 $90.TEXT 'STX' ; 147 $93.TEXT 'STY' ; 150 $96.TEXT 'TAX' ; 153 $99.TEXT 'TAY' ; 156 $9C.TEXT 'TSX' ; 159 $9F.TEXT 'TXA' ; 162 $A2.TEXT 'TXS' ; 165 $A5.TEXT 'TYA' ; 168 $A8;*********************************; QUASI-OPCODES;*********************************.TEXT 'ASO' ; 171 $AB.TEXT 'RLA' ; 174 $AE.TEXT 'LSE' ; 177 $B1.TEXT 'RRA' ; 180 $B4.TEXT 'AXS' ; 183 $B7.TEXT 'LAX' ; 186 $BA.TEXT 'DCM' ; 189 $BD.TEXT 'INS' ; 192 $C0.TEXT 'ALR' ; 195 $C3.TEXT 'ARR' ; 198 $C6.TEXT 'OAL' ; 201 $C9.TEXT 'SAX' ; 204 $CC.TEXT 'NOP' ; 207 $CF.TEXT 'SKB' ; 210 $D2.TEXT 'SKW' ; 213 $D5;*********************************; TABLE OF MNEMONIC CODES;*********************************;;A MNEMONIC'S CODE IS ITS OFFSET;    INTO MNAMES, THE LIST OF;         MNEONIC NAMES.;;*********************************MCODES = *;     0X  1X  2X  3X  4X  5X  6X  7X; 0X  BRK ORA KIL SLO NOP ORA ASL SLO.BYTE $21,$69,$00,$00,$00,$69,$09,$00;     8X  9X  AX  BX  CX  DX  EX  FX     ;PHP ORA ASL ANC NOP ORA ASL SLO.BYTE $6F,$69,$09,$00,$00,$69,$09,$00; 1X  BPL ORA KIL SLO NOP ORA ASL SLO.BYTE $1E,$69,$00,$00,$00,$69,$09,$00     ;CLC ORA NOP SLO NOP ORA ASL SLO.BYTE $2A,$69,$00,$00,$00,$69,$09,$00; 2X  JSR AND KIL RLA BIT AND ROL RLA.BYTE $57,$06,$00,$00,$15,$06,$78,$00     ;PLP ABD ROL ANC BIT AND ROL RLA.BYTE $75,$06,$78,$00,$15,$06,$78,$00; 3X  BMI AND KIL RLA NOP AND ROL RLA.BYTE $18,$06,$00,$00,$00,$06,$78,$00;     SEC AND NOP RLA NOP AND ROL RLA.BYTE $87,$06,$00,$00,$00,$06,$78,$00; 4X  RTI EOR KIL SRE NOP EOR LSR SRE.BYTE $7E,$48,$00,$00,$00,$48,$63,$00;     PHA EOR LSR ALR JMP EOR LSR SRE.BYTE $6C,$48,$63,$00,$54,$48,$63,$00; 5X  BVC EOR KIL SRE NOP EOR LSR SRE.BYTE $24,$48,$00,$00,$00,$48,$63,$00;     CLI EOR NOP SRE NOP EOR LSR SRE.BYTE $30,$48,$00,$00,$00,$48,$63,$00; 6X  RTS ADC KIL RRA NOP ADC ROR RRA.BYTE $81,$03,$00,$00,$00,$03,$7B,$00;     PLA ADC ROR ARR JMP ADC ROR RRA.BYTE $72,$03,$7B,$00,$54,$03,$7B,$00; 7X  BVS ADC KIL RRA NOP ADC ROR RRA.BYTE $27,$03,$00,$00,$00,$03,$7B,$00;     SEI ADC NOP RRA NOP ADC ROR RRA.BYTE $8D,$03,$00,$00,$00,$03,$7B,$00; 8X  NOP STA NOP SAX STY STA STX SAX.BYTE $00,$90,$00,$00,$96,$90,$93,$00;     DEY NOP TXA XXA STY STA STX SAX.BYTE $45,$00,$A2,$00,$96,$90,$93,$00; 9X  BCC STA KIL AHX STY STA STX SAX .BYTE $0C,$90,$00,$00,$96,$90,$93,$00;     TYA STA TXS TAS SHY STA SHX AHX.BYTE $A8,$90,$A5,$00,$00,$90,$00,$00; AX  LDY LDA LDX LAX LDY LDA LDX LAX.BYTE $60,$5A,$5D,$00,$60,$5A,$5D,$00;     TAY LDA TAX LAX LDY LDA LDX LAX.BYTE $9C,$5A,$99,$00,$60,$5A,$5D,$00; BX  BCS LDA KIL LAX LDY LDA LDX LAX.BYTE $0F,$5A,$00,$00,$60,$5A,$5D,$00;     CLV LDA TSX LAS LDY LDA LDX LAX.BYTE $33,$5A,$9F,$00,$60,$5A,$5D,$00; CX  CPY CMP NOP DCP CPY CMP DEC DCP.BYTE $3C,$36,$00,$00,$3C,$36,$3F,$00;     INY CMP DEX AXS CPY CMP DEC DCP.BYTE $51,$36,$42,$00,$3C,$36,$3F,$00; DX  BNE CMP KIL DCP NOP CMP DEC DCP.BYTE $1B,$36,$00,$00,$00,$36,$3F,$00;     CLD CMP NOP DCP NOP CMP DEC DCP.BYTE $2D,$36,$00,$00,$00,$36,$3F,$00; EX  CPX SBC NOP ISC CPX SBC INC ISC.BYTE $39,$84,$00,$00,$39,$84,$4B,$00;     INX SBC NOP SBC CPX SBC INC ISC.BYTE $4E,$84,$66,$00,$39,$84,$4B,$00; FX  BEQ SBC KIL ISC NOP SBC INC ISC.BYTE $12,$84,$00,$00,$00,$84,$4B,$00;     SED SBC NOP ISC NOP SBC INC ISC.BYTE $8A,$84,$00,$00,$00,$84,$4B,$00;*********************************; TABLE OF ADDRESSING MODE CODES;*********************************;; AN ADDRESSING MODE'S CODE IS; ITS OFFSET INTO SUBS, THE TABLE; OF ADDRESSING MODE SUBROUTINES;; ILLEGL ; 0  $00; ACC    ; 2  $02; IMMEDT ; 4  $04; ZEROPG ; 6  $06; ZEROX  ; 8  $08; ZEROY  ; 10 $0A; ABSLUT ; 12 $0C; ABSX   ; 14 $0E; ABSY   ; 16 $10; IMPLID ; 18 $12; RELATV ; 20 $14; INDX   ; 22 $16; INDY   ; 24 $18; INDRCT ; 26 $1A;*********************************MODES = * ; 0X   0  1 2 3 4 5 6 7.BYTE 18,22,0,0,0,6,6,0;      8  9 A B C D E F.BYTE 18,4,2,0,0,12,12,0; 1X   0  1 2 3 4 5 6 7.BYTE 20,24,0,0,0,8,8,0;      8  9 A B C D E F.BYTE 18,16,0,0,0,14,14,0; 2X   0  1 2 3 4 5 6 7.BYTE 12,22,0,0,6,6,6,0;.BYTE 12,22,0,0,28,6,6,0;      8  9 A B C D E F.BYTE 18,4,2,0,12,12,12,0;.BYTE 18,4,2,0,30,12,12,0; 3X   0  1 2 3 4 5 6 7.BYTE 20,24,0,0,0,8,8,0;      8  9 A B C D E F.BYTE 18,16,0,0,0,14,14,0; 4X   0  1 2 3 4 5 6 7.BYTE 18,22,0,0,0,6,6,0;      8  9 A B C D E F.BYTE 18,4,2,0,12,12,12,0; 5X   0  1 2 3 4 5 6 7.BYTE 20,24,0,0,0,8,8,0;      8  9 A B C D E F.BYTE 18,16,0,0,0,14,14,0; 6X   0  1 2 3 4 5 6 7.BYTE 18,22,0,0,0,6,6,0;      8  9 A B C D E F.BYTE 18,4,2,0,26,12,12,0; 7X   0  1 2 3 4 5 6 7.BYTE 20,24,0,0,0,8,8,0;      8  9 A B C D E F.BYTE 18,16,0,0,0,14,14,0; 8X   0  1 2 3 4 5 6 7.BYTE 0,22,0,0,6,6,6,0;      8  9 A B C D E F.BYTE 18,0,18,0,12,12,12,0; 9X   0  1 2 3 4 5 6 7.BYTE 20,24,0,0,8,8,10,0;      8  9 A B C D E F.BYTE 18,16,18,0,0,14,0,0; AX   0  1 2 3 4 5 6 7.BYTE 4,22,4,0,6,6,6,0;      8  9 A B C D E F.BYTE 18,4,18,0,12,12,12,0; BX   0  1 2 3 4 5 6 7.BYTE 20,24,0,0,8,8,10,0;      8  9 A B C D E F.BYTE 18,16,18,0,14,14,16,0; CX   0  1 2 3 4 5 6 7.BYTE 4,22,0,0,6,6,6,0;      8  9 A B C D E F.BYTE 18,4,18,0,12,12,12,0; DX   0  1 2 3 4 5 6 7.BYTE 20,24,0,0,0,8,8,0;      8  9 A B C D E F.BYTE 18,16,0,0,0,14,14,0; EX   0  1 2 3 4 5 6 7.BYTE 4,22,0,0,6,6,6,0;      8  9 A B C D E F.BYTE 18,4,18,0,12,12,12,0; FX   0  1 2 3 4 5 6 7.BYTE 20,24,0,0,0,8,8,0;      8  9 A B C D E F.BYTE 18,16,0,0,0,14,14,0;*********************************;.FIL 0:SYM.ASM;*********************************;.END;*********************************; FILE SYMBOL.ASM;*********************************;;        DISASSEMBLER64;    SYMBOLIC DISASSEMBLER;       BY DENTON MARLOWE;;  (C)1986 BY DENTON MARLOWE;;*********************************; SYMBOLIC ROUTINES;*********************************; SYMBOLIC DISASSEMBLY OPTION;*********************************SOP    LDA #<MSS1  ;LOW BYTE MESSAGE       LDY #>MSS1  ;HIGH BYTE MESSAGE       JSR STRPNT  ;OUTPUT MESSAGE;      JSR CRNO    ;GET KEY PRESS       JSR CRYS       BCC SOP1    ;C=0 YES;*********************************; ABSOLUTE DISASSEMBLY SELECTED;*********************************       LDA #$00    ;SET SYMBLOIC FLAG       STA SYMBOL  ;STORE FLAG       JMP SY      ;FOR INTERNAL;*********************************; SYMBOLIC DISASSEMBLY SELECTED;*********************************SOP1   LDA #$01    ;SET SYMBOLIC FLAG       STA SYMBOL  ;STORE FLAG;*********************************; SETUP START OF TABLE POINTER;********************************* LDA #<STABLE STA SYMBOS STA SYMBOP LDA #>STABLE STA SYMBOS+1 STA SYMBOP+1;*********************************; CHECK FOR SYMBOL TABLE OPTION;*********************************SYTAB LDA #<MSS2 ;LOW BYTE MESSAGE LDY #>MSS2 ;HIGH BYTE MESSAGE JSR STRPNT ;OUTPUT MESSAGE JSR CRNO ;GET KEY PRESS BCS SY ;C=1 NO;*********************************; APPEND SYMBOL TABLE;********************************* LDA #<MSS4 LDY #>MSS4 JSR STRPNT JSR CRNO BCS SOP4 LDA #<UTABLE STA SYMBOP LDA #>UTABLE STA SYMBOP+1;*********************************; GO AND LOAD TABLE;*********************************SOP4 JSR READXX ;READ FILE BCS SY ;C=1 ERROR;*********************************; SETUP END OF TABLE POINTER;********************************* LDA SYMBOP ;XREF POINTER STA SYMBOE LDA SYMBOP+1 STA SYMBOE+1 RTS;*********************************; DEFAULT SYMBOL TABLE END;*********************************SY LDA #<UTABLE STA SYMBOE LDA #>UTABLE STA SYMBOE+1 RTS;*********************************; SET OR RESET SYMBOL TABLE;*********************************SSET LDA SYMBOS STA SYMBOP LDA SYMBOS+1 STA SYMBOP+1 RTS;*********************************; EQUATE TABLE SETUP;*********************************EQUINT LDA TABINE STA TABINP STA TABINS LDA TABINE+1 STA TABINP+1 STA TABINS+1 RTS;*********************************; ENTRY POINT FOR ADDRESS;*********************************SYM LDA SYMBOL BEQ SYMEND LDA SELECT ;COPY SELECT STA WORKED ;ADDRESS INTO LDA SELECT+1 ;WORKED STA WORKED+1 JMP SYM1 ;CHECK FOR MATCH;*********************************; ENTRY POINT FOR OPCODES;*********************************SYMOP LDA SYMBOL BEQ SYMEND;*********************************; COMPARE ADDRESS TO SYMBOL TABLE;*********************************SYM1 JSR SSETSYM2 JSR GETC STA WORKER+1 JSR INCC JSR GETC STA WORKER;********************************* SEC ;SET CARRY LDA WORKER SBC WORKED ;SUB FROM LOW STA TEMP ;STORE RESULT LDA WORKER+1 SBC WORKED+1 ;SUB FROM HIGH ORA TEMP ;OR RESULTS BEQ MATCH ;CHECK FOR MATCH JSR NEXTC ;IF NOT NEXT BCS SYMEND ;END OF TABLE? JMP SYM2 ;NO CHECK NEXTSYMEND CLC ;NO MATCHES CLEAR RTS ;RETURN;*********************************; FOUND MATCH;*********************************MATCH LDA PASS ;CHECK PASS CMP CPASS ;IS IT LAST BEQ MATCHS ;IF SO PRINT CMP SPASS BEQ MATCHT JSR RANGE ;SYMBOL IN RANGE BCC MATEXT ;NO INTERNAL EQ JSR INCC ;INC TO SYMBOL JSR GETC ;GET FIRST CHAR CMP #$20 ;SPACE BEQ MATONE ;NOT EQUATE JMP PUTI ;PUT IN EQUATEMATONE RTS ;RETURN;*********************************; CHECK FOR SYMBOL+1;*********************************MATCHS JSR INCC ;INC TO LABEL JSR GETC ;GET CHARARCTER CMP #$20 ;IS IT SPACE BNE MATCHT ;IF NOT GO ON SEC ;SET CARRY LDA SYMBOP ;GET LOW POINT SBC #$09 ;LAST SYMBOL PHA ;PUSH ON STACK LDA SYMBOP+1 ;GET HIGH POINT SBC #$00 ;LAST SYMBOL TAY ;PUT IN Y PLA ;GET LO POINT JSR STRSYM ;PRINT SYMBOL LDA #'+'         ;ASCII + JSR PCHAR ;PRINT IT LDA #'1'         ;ASCII 1 JSR PCHAR ;PRINT IT SEC ;C=1 SYMBOL RTS ;RETURN;*********************************MATCHT LDA SYMBOP ;LOW BYTE LABEL LDY SYMBOP+1 ;HIGH BYTE LABEL JSR STRSYM ;PRINT LABEL;********************************* SEC ;MATCH SET CARRYMATEXT RTS ;RETURN;*********************************; PRINT SYMBOL;*********************************STRSYM STA ZEROUR STY ZEROUR+1 LDY #$00STRSY1 LDA (ZEROUR),Y BEQ SYEXIT CMP #$20 BEQ SYEXIT JSR PCHAR INY BNE STRSY1SYEXIT RTSFIXSYM LDA (ZEROUR),Y BEQ SYEXIT JSR PCHAR INY JMP FIXSYM;*********************************; INC SYMBOL ADDRESS TABLE POINTER;*********************************NEXTC CLC LDA SYMBOP ADC #$08 STA SYMBOP LDA SYMBOP+1 ADC #$00 STA SYMBOP+1 CMP SYMBOE+1 BCC COK BNE NCOK LDA SYMBOP CMP SYMBOE BCS NCOKCOK CLC RTSNCOK SEC RTS;*********************************INCC INC SYMBOP BNE *+5 INC SYMBOP+1 RTS;*********************************; GET BYTE FROM ADDRESS TABLE;*********************************GETC LDA SYMBOP STA ZEROUR LDA SYMBOP+1 STA ZEROUR+1 LDY #$00 LDA (ZEROUR),Y RTS;*********************************; PRINT EQUATE TABLE;*********************************EQUPRT SEC LDA TABINS SBC TABINE STA TEMP LDA TABINS+1 SBC TABINE+1 ORA TEMP BEQ EQUEND JSR SORT JSR COMENT JSR PRTOTH LDA #<EQUATE LDY #>EQUATE JSR STRPNT JSR NEWLIN JSR COMENTEQUOP JSR GETI STA WORKED JSR INCI JSR GETI STA WORKED+1 JSR PRTOTH JSR SYMOP BCS EQUOP1 JSR PWORKEQUOP1 LDA #'=' JSR PCHAR LDA #'$' JSR PCHAR JSR PWORKD JSR NEWLIN;********************************* JSR INCI LDA TABINP+1 CMP TABINE+1 BCC EQUOP BNE EQUEND LDA TABINP CMP TABINE BCC EQUOP;*********************************EQUEND JSR COMENT JMP RESINT;*********************************; READ CROSS REFERENCE SEQ FILE;      INTO SYMBOL TABLE;*********************************; READ FILE NAME DEFAULT ON CR;*********************************READXX LDA #<MSS3 LDY #>MSS3 JSR STRPNTSOP2 JSR GETIN BEQ SOP2 CMP #'0' BEQ SOP3 CMP #'1' BNE SOP2SOP3 JSR CHROUT STA TEXTER;********************************* LDA #<LOADF LDY #>LOADF JSR STRPNT;********************************* JSR INSTNG BEQ READXF TYA PHA JSR INITD PLA TAY LDX #$00XFILE1 LDA NAMS,X STA BUF,Y INY INX CPX #$04 BNE XFILE1 TYA LDY #>BUF LDX #<BUF JSR SETNAM JMP REOPEN;*********************************; DEFAULT FILENAME XRFF0000;********************************READXF LDA #$0E LDY #>NAME LDX #<NAME JSR SETNAM;*********************************; OPEN FILE;********************************REOPEN LDA #$03 LDX #$08 LDY #$03 JSR SETLFS JSR OPEN;********************************; CHECK FOR DISK ERROR;********************************* JSR DISERR BCS QUITXX;*********************************; OUTPUT LOADING MESSAGE;********************************* LDA #<LOADM ;MSG LOW LDY #>LOADM ;MSG HIGH JSR STRPNT ;OUTPUT MSG;********************************* LDA #$00 ;COL COUNTER STA TEMP;*********************************; INPUT AND LOAD SYMBOL TABLE;*********************************READX JSR READS ;INPUT SYMBOL JSR PUTC JSR LINES ;SCREEN OUT JSR STOP BEQ QUITX JSR READST BEQ READX;*********************************;    CLOSE OPEN FILE;*********************************QUITX LDA #$03 JSR CLOSE JSR CLRCHN JSR CRLF;*********************************; SET END OF TABLE;********************************* LDA SYMBOP STA SYMBOE LDA SYMBOP+1 STA SYMBOE+1;*********************************; OUTPUT LOADED MESSAGE;********************************* LDA #<LOADC LDY #>LOADC JSR STRPNT CLC RTS;*********************************; OUTPUT ERROR MESSAGE;*********************************QUITXX LDA #$03 JSR CLOSE JSR CLRCHN LDA #<LOADE LDY #>LOADE JSR STRPNT SEC RTS;*********************************; READ SYMBOL FROM FILE;*********************************READS LDX #$03 ;FILE NUMBER JSR CHKIN ;FILE IS INPUT LDY #$02 ;COUNTER JSR CHRIN ;INPUT CHAR STA SYMBUF,Y ;1ST CHAR JSR CHROUT ;PRITN IT INY ;INC POINTERREADY JSR CHRIN ;NEXT CHAR STA SYMBUF,Y ;STORE JSR CHROUT ;PRINT IT INY ;INC OFFSET CPY #$08 ;8 IS FOR NULL BNE READY ;BRANCH IF NOT LDA #$00 ;NULL MARKER STA SYMBUF,Y ;STORE AT END;********************************* JSR SPACE ;PRINT SPACE JSR DOLLAR ;PRINT $ SIGN;********************************* LDA TEXTER CMP #'0' BEQ STDREF;********************************* LDY #$00 JSR XGET INY JSR XGET JSR CHRIN ;GET $0D JMP CLRCHN;*********************************XGET JSR CHRIN JSR CHROUT JSR BINARY ASL A ASL A ASL A ASL A STA SYMBUF,Y JSR CHRIN JSR CHROUT JSR BINARY ORA SYMBUF,Y STA SYMBUF,Y RTS;*********************************STDREF LDY #$00 ;ZERO OFFSET JSR CHRIN ;HIGH BYTES STA SYMBUF,Y ; STY SAVY ; JSR PRBYT ; LDY SAVY ; INY ; JSR CHRIN ;LOW BYTE STA SYMBUF,Y ; JSR PRBYT ; JMP CLRCHN ;KEYBOARD INPUT;*********************************; MOVE SYMBOL FROM BUFFER TO TABLE;*********************************PUTC LDY #$00 LDA SYMBOP STA ZEROUR LDA SYMBOP+1 STA ZEROUR+1PUT LDA SYMBUF,Y STA (ZEROUR),Y INY CPY #$09 BNE PUT CLC LDA SYMBOP ADC #$09 STA SYMBOP LDA SYMBOP+1 ADC #$00 STA SYMBOP+1 RTS;*********************************; OUTPUT SYMBOL IN 4 COLUMNS;*********************************LINES INC TEMP LDA #$03 CMP TEMP BEQ RESET LDA #'.' JMP CHROUTRESET LDA #$00 STA TEMP LDA #$0D JMP CHROUT;*********************************;   COMMAND MESSAGES;*********************************NAME .TEXT '0:XRLL0000'NAMS .TEXT ',S,R';*********************************MSS1 .BYTE $0D .BYTE $0D .TEXT 'SYMBOLIC DISASSEMBLY' .BYTE $0D .TEXT '(Y OR N/CR)? ' .BYTE 0 MSS2 .BYTE $0D .BYTE $0D .TEXT 'LOAD USER' .BYTE $0D .TEXT 'SYMBOL TABLE' .BYTE $0D .TEXT '(Y OR N/CR)? ' .BYTE 0 MSS3 .BYTE $0D .BYTE $0D .TEXT 'FORMAT' .BYTE $0D .TEXT '0=STANDARD' .BYTE $0D .TEXT '1=ASCII : ' .BYTE 0 MSS4 .BYTE $0D .BYTE $0D .TEXT 'APPEND DEFAULT TABLE' .BYTE $0D .TEXT '(Y OR N/CR)? ' .BYTE 0LOADF .BYTE $0D.BYTE $0D.TEXT 'SYMBOL TABLE'.BYTE $0D.TEXT '(CR OR D:NAME): '.BYTE 0LOADM .BYTE $0D,$0D.TEXT 'READING SYMBOL'.BYTE $0D.TEXT 'TABLE FILE'.BYTE $0D,$0D.BYTE 0LOADC .BYTE $0D.BYTE $0D.TEXT 'SYMBOL TABLE'.BYTE $0D.TEXT 'LOADED'.BYTE $0D,$0D.BYTE 0LOADE .BYTE $0D.BYTE $0D.TEXT 'SYMBOL TABLE'.BYTE $0D.TEXT 'NOT LOADED'.BYTE $0D,$0D.BYTE 0;*********************************EQUATE .TEXT '; EXTERNAL ADDRESS EQUATES' .BYTE 0;*********************************; PATCH CODE AREA;**********************************=*+$0800;*********************************; BIT INSTRUCTION CODING;*********************************BITOPT = *       LDA #<MSB1 ;TABLE TYPE       LDY #>MSB1       JSR STRPNTBOP0   JSR GETIN       BEQ BOP0       CMP #'0'   ;STANDARD       BEQ BSC       CMP #'1'   ;$2C ABS       BEQ BSC        CMP #'2'   ;$24 ZP       BEQ BSC       CMP #'3'   ;$2C AND $24       BEQ BSC       CMP #$0D   ;STANDARD       BNE BOP0       LDA #'0'BSC = *       PHA        ;STASH INPUT       JSR CHROUT ;OUTPUT FEEDBACK       PLA        ;POP INPUT       EOR #$30   ;MAKE A NUMBER       STA BITFLG ;SET FLAG       RTS;*********************************; BIT INSTRUCTION CODING FLAG;*********************************BITFLG = *       .BYTE $AA;*********************************;*********************************; SYMBOL TABLE;*********************************;  KERNAL JUMP TABLE;*********************************STABLE = * .TEXT $FF,$80,'IDBYTE',0 .TEXT $FF,$81,'CINT  ',0 .TEXT $FF,$84,'IOINIT',0 .TEXT $FF,$87,'RAMTAS',0 .TEXT $FF,$8A,'RESTOR',0 .TEXT $FF,$8D,'VECTOR',0 .TEXT $FF,$90,'SETMSG',0 .TEXT $FF,$93,'SECOND',0 .TEXT $FF,$96,'TKSA  ',0 .TEXT $FF,$99,'MEMTOP',0 .TEXT $FF,$9C,'MEMBOT',0 .TEXT $FF,$9F,'SCNKEY',0 .TEXT $FF,$A2,'SETTMO',0 .TEXT $FF,$A5,'ACPTR ',0 .TEXT $FF,$A8,'CIOUT ',0 .TEXT $FF,$AB,'UNTLK ',0 .TEXT $FF,$AE,'UNLSN ',0 .TEXT $FF,$B1,'LISTEN',0 .TEXT $FF,$B4,'TALK  ',0 .TEXT $FF,$B7,'READST',0 .TEXT $FF,$BA,'SETLFS',0 .TEXT $FF,$BD,'SETNAM',0 .TEXT $FF,$C0,'OPEN  ',0 .TEXT $FF,$C3,'CLOSE ',0 .TEXT $FF,$C6,'CHKIN ',0 .TEXT $FF,$C9,'CHKOUT',0 .TEXT $FF,$CC,'CLRCHN',0 .TEXT $FF,$CF,'CHRIN ',0 .TEXT $FF,$D2,'CHROUT',0 .TEXT $FF,$D5,'LOAD  ',0 .TEXT $FF,$D8,'SAVE  ',0 .TEXT $FF,$DB,'SETTIM',0 .TEXT $FF,$DE,'RDTIM ',0 .TEXT $FF,$E1,'STOP  ',0 .TEXT $FF,$E4,'GETIN ',0 .TEXT $FF,$E7,'CLALL ',0 .TEXT $FF,$EA,'UDTIM ',0 .TEXT $FF,$ED,'SCREEN',0 .TEXT $FF,$F0,'PLOT  ',0 .TEXT $FF,$F3,'IOBASE',0;********************************* .TEXT $FF,$FA,'NMIVEC',0 .TEXT $FF,$FC,'RESVEC',0 .TEXT $FF,$FE,'IRQVEC',0;*********************************UTABLE .BYTE 0;*********************************.END